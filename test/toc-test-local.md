<!--\*\*poetryBold\*\*-->

<localized main="en"/>
<!--ru~{{and}}~и~-->
<!--uk~{{and}}~і~-->
<!--en~{{and}}~and~-->

<!--ru~{{RED}}~style="color:red;"~-->
<!--uk~{{RED}}~style="color:red;"~-->
<!--en~{{RED}}~style="color:red;"~-->

<!--ru~{{or}}~или~-->
<!--uk~{{or}}~або~-->
<!--en~{{or}}~or~-->

<!--ru~{{Review}}~Ревью~-->
<!--uk~{{Review}}~Рев’ю~-->
<!--en~{{Review}}~Review~-->

<codalized main="js"/>

<!--js~{{Selenide}}~SelenideJs~-->
<!--ts~{{Selenide}}~SelenideJs~-->
<!--py~{{Selenide}}~Selene~-->
<!--java~{{Selenide}}~Selenide~-->
<!--cs~{{Selenide}}~NSelene~-->

<!--js~{{TestRunner}}~Jest~-->
<!--ts~{{TestRunner}}~Jest~-->
<!--py~{{TestRunner}}~Pytest~-->
<!--java~{{TestRunner}}~JUnit~-->
<!--cs~{{TestRunner}}~NUnit~-->

<!--js~{{by}}~by.*(value)~-->
<!--ts~{{by}}~by.*(value)~-->
<!--py~{{by}}~by.*(value)~-->
<!--java~{{by}}~By.*(value)~-->
<!--cs~{{by}}~By.*(value)~-->

# <ru>CSS-селекторы против селенидов</ru><uk>CSS-селектори проти селенідів</uk><en>CSS-selectors vs selenides</en>: {{Review}}

## <ru>Список частых ошибок</ru><uk>Список частих помилок</uk><en>List of common mistakes</en> {#fam}

<ru>Анализируя задокументированные типичные ошибки ниже, улучши свое решение, исправив их соответственно. Старайся не просто подглядывать в решение к ошибкам, но, используя подсказки и объяснения, сначала найди решение самостоятельно, и после – сверься с предоставленым решением.</ru><uk>Аналізуючи задокументовані типові помилки нижче, покращи своє рішення, виправивши їх відповідно. Старайся не просто підглядати в розв’язки до помилок, але, використовуючи підказки і пояснення, спочатку знайди рішення самостійно, і після – порівняйся з наданим розв’язком.</uk><en>Analyzing the documented typical mistakes below, improve your solution by fixing them accordingly. Try not just to pry into the solution to the mistakes, but, using the tips and explanations, first find the solution yourself, and then compare it with the provided solution.</en>

<!--TODO: fix the broken TOC below
currently it will show not relevant to other langs headers-->

[TOC]<!--TOC>2-->

## <ru>Разборы других решений</ru><uk>Розбори інших розв’язків</uk><en>Other solutions reviews</en> {#video-reviews}

<ru>Проcмотри записи разборов других решений, старательно исправляя свои собственные ошибки при просмотре. Если ты уже получил финальное решение, засчитанное твоим ментором, то все равно просмотри разборы других, с целью натренировать навыки код-ревью. Во время просмотра останавливай запись, и пробуй найти в коде ошибки самостоятельно, а потом сравнивай с теми что будут найдены в разборы. Может ты найдешь больше ;)</ru><uk>Переглянь записи розборів інших розв’язків, старанно виправляючи свої власні помилки при перегляді. Якщо ти вже отримав фінальний розв’язок, зарахований твоїм ментором, то все одно переглянь розбори інших, з метою натренувати навички код-рев’ю. Під час перегляду зупиняй запис, і пробуй знайти в коді помилки самостійно, а потім порівнюй з тими що будуть знайдені в розборі далі. Може ти знайдеш більше ;)</uk><en>Watch the recordings of other solutions reviews, carefully correcting your own mistakes while watching. If you have already received a final solution approved by your mentor, then still watch the reviews of others, in order to train your code review skills. While watching, stop the recording, and try to find the errors in the code yourself, and then compare with those that will be found in the reviews. Maybe you will find more ;)</en>

<java>

<ru>

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/Rcbz-oNtgIk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</ru>

<uk>

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/I1SBGzclwE0 " frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</uk>

<en>

**<p {{RED}}>Waiting for new recordings...</p>**

</en>

</java>

<py>

<ru>

**<p {{RED}}>Waiting for new recordings...</p>**

</ru>

<uk>

<div style="position: relative; padding-bottom: 56.25%; height: 0;"><iframe src="https://www.loom.com/embed/ef9056f96e1644f7b21c85ebffdd378a" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></iframe></div>

</uk>

<en>

**<p {{RED}}>Waiting for new recordings...</p>**

</en>

</py>

<js-ts>

<ru>

<div style="position: relative; padding-bottom: 56.25%; height: 0;"><iframe src="https://www.loom.com/embed/09c97fcc9ed24fdc830062f778d01828" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></iframe></div>

,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

<div style="position: relative; padding-bottom: 56.25%; height: 0;"><iframe src="https://www.loom.com/embed/abd1e0b315224918836a85d32073e2b8" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></iframe></div>

,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

<div style="position: relative; padding-bottom: 56.25%; height: 0;"><iframe src="https://www.loom.com/embed/5b0e21d5351a44959383c69a98af3d94" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></iframe></div>

,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

<div style="position: relative; padding-bottom: 56.25%; height: 0;"><iframe src="https://www.loom.com/embed/d8a946db5737447385607ab82050583e" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></iframe></div>

,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

<div style="position: relative; padding-bottom: 56.25%; height: 0;"><iframe src="https://www.loom.com/embed/127e2ad86d604ab280890d7014d7db9f" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></iframe></div>

,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

<div style="position: relative; padding-bottom: 56.25%; height: 0;"><iframe src="https://www.loom.com/embed/73cb6496cafd43759e7d9c171a569d13" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></iframe></div>

,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

<div style="position: relative; padding-bottom: 56.25%; height: 0;"><iframe src="https://www.loom.com/embed/3fd4b2317d2548bc80f8a97e9fda326e" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></iframe></div>

,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

<div style="position: relative; padding-bottom: 56.25%; height: 0;"><iframe src="https://www.loom.com/embed/97d4056468f84699bf7a4c8e5063c04c" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></iframe></div>

,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

<div style="position: relative; padding-bottom: 56.25%; height: 0;"><iframe src="https://www.loom.com/embed/947598fd90f74abd936d07198a5dd3bd" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></iframe></div>

,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

</ru>

<uk>

<div style="position: relative; padding-bottom: 56.25%; height: 0;"><iframe src="https://www.loom.com/embed/947598fd90f74abd936d07198a5dd3bd" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></iframe></div>

</uk>

<en>

**<p {{RED}}>Waiting for new recordings...</p>**

</en>

</js-ts>

<cs>

**<p {{RED}}><en>Waiting for recordings...</en><uk>Очікуємо на записи...</uk><ru>Ожидаем записи...</ru></p>**

</cs>

==================

<js-ts>

**<p {{RED}}><en>Waiting for mistakes to be documented...</en><uk>Очікуємо на документацію помилок...</uk><ru>Ожидаем документацию ошибок...</ru></p>**

</js-ts>

<cs>

**<p {{RED}}><en>Waiting for mistakes to be documented...</en><uk>Очікуємо на документацію помилок...</uk><ru>Ожидаем документацию ошибок...</ru></p>**

</cs>

<java>

<ru>

<!--TODO: qaestify everything below, probably taking py-uk as example, yet finally approve the format with @yashaka -->

### Структурная информация в именах тест-суита и тестов, которая не несет пользы с точки зрения тестирования {#structural-info-in-test-names}

*Пример 1*

```poetry
public class TodoMvc**CssVersionTest** {

    @Test
    void completesTodo() {
```

*Пример 2*

```poetry
public class TodoMvcTest {

    @Test
    void completesTodo**CssVersion** {
```

Имена тест-класса и тест-метода играют, по сути, роль имен «тест-суита» и «тест-кейса» соответственно, а последние – должны отображать то, что мы тестируем, а не, например, «нюансы реализации», как в примерах выше. Если хочется структурировать свои решения для заданий – лучше создать отдельные папки и разложить в них, как по полочкам – разные версии решений.

*Например так... (ищи решение дальше)*

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РЕШЕНИЕ⇩**

============



```poetry
selenide-intro/
  src/
    test/
      java/
        com/
          yashaka/
            selenideintro/
              **csstodo**/
                TodoMvcTest.java
              **xpathtodo**/
                TodoMvcTest.java
```



===============================================

### Несоответствие имен тест-суита или тест-кейсов целям тестирования {#describe-and-it-names-does-not-reflect-test-goals}

*Пример 1*

```poetry
public class TodoMvcTest {

    //...

    @Test
    void **testTodoMvc**() {

```

*Пример 2*

```poetry
public class TodoMvc**Completes**Test {

    //...

    @Test
    void completes() {

```

Имена тест-класса и тест-метода играют, по сути, роль имен «тест-суита» и «тест-кейсов» соответственно, а последние – должны отображать то, что мы тестируем. В первом примере выше имя тест-метода не несет совсем никакой полезной информации с точки зрения целей тестирования для нашего сценария. Во втором примере имя тест-класса недостаточно абстрактно в контексте нашего покрытия (мы как раз «завершение» задачи покрываем в тест-методе).

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РЕШЕНИЕ⇩**

============



```poetry
public class **TodoMvcTest** {

    //...

    @Test
    void **completesTodo**() {
```



========================================

### Установка пути к chromedriver в коде {#setting-path-to-chromedriver-in-the-code}

*Пример*

```poetry
System.setProperty("webdriver.chrome.driver", "**C:/work/web drivers/chromedriver.exe**");

```

Обычно, намного проще и универсальней **прописать путь к chromedriver в системную переменную окружения PATH** (возможно, чтобы изменения вступили в силу, придется перегрузить OS). Такое решение лучше по той причине, что тесты могут быть запущены на разных машинах, и если мы пропишем точный путь в коде тестов к chromedriver – нам придется на всех машинах подгонять местоположение драйвера к этому пути. А что делать, если мы захотим запустить тесты под другой OS, где и пути-то могут быть совсем в другом формате? ;) Поэтому лучше переложить обязанность за «установку пути драйвера» с кода тестов на конфигурации машин для запуска тестов.

Как установить PATH? – можно загуглить решение конкретно под нужную OS;)



=========================================

### Использование «запрещенных в задании методов Selenide» {#using-todo-forbidden-selenide-methods}

*Пример*

```poetry
element("#todo-list>li:nth-child(2)")**.find(**".toggle"**)**.click();
```

В этом задании мы учимся находить элементы только силами CSS. В заданиях указано, какие типы методов нельзя использовать;)

В примере выше использован метод `SelenideElement#find` (метод `find`, вызванный для объекта класса `SelenideElement`, который возвращает статический метод `element` класса Selenide), он позволяет найти внутренний элемент по селектору внутри другого, а наша задача – научиться такому «внутреннему поиску» только с помощью CSS селекторов в этом задании;)

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РЕШЕНИЕ⇩**

============



```poetry
element("#todo-list>li:nth-child(2) .toggle").click();
```



==========================

### Хрупкие строгие локаторы {#fragile-strict-locators}

Обычно есть несколько способов написать локатор чтобы найти один тот же элемент на странице. Можно использовать очень много информации о структуре html (вложенность элементов, порядок их следования один за другим) и содержании (тексты, значения атрибутов элементов) и тогда получится «строгий» локатор. Или использовать минимум информации – и тогда получится «слабый» или «гибкий» локатор. В следующей серии ошибок мы расcмотрим типичные случаи, когда [строгие локаторы приводят к нестабильным «хрупким» тестам](#strict-or-stable-locators) (flaky tests).



==========================================

### Хрупкие строгие локаторы. Избыточность в путях – привязка к тегу {#fragile-strict-locators-binding-to-tag}

Допустим, у нас есть элементы:

```html
<li>
  <div class="crd">
    <label>1</label>
    <input type="button" class="destroy"/>
  </div>
  ...
</li>
<li>
  <div class="crd">
    <label>2</label>
    <input type="button" class="destroy"/>
  </div>
  ...
</li>
...
```

Тогда следующий селектор, вероятно, будет «хрупким»:

```poetry
li:nth-child(2) **input**.destroy
```

Для точного определения элементов лучшей практикой в разработке внутреннего представления html страниц принято использовать атрибуты элементов, в большинстве случаев – `id` (для определения уникальных элементов) и `class` (для определения группы однотипных элементов). Поэтому использовать теги элементов, особенно когда элемент можно определить по css классу – менее предпочтительно. В нашем случае внутренняя реализация может, например, поменяться от:

```html
    <input type="button" class="destroy">
```

до

```html
    <button class="destroy"></button>
```

В таком случае наш селектор перестанет работать и тест упадет. Хотя функционал, по сути, не поменялся – как была кнопка удаления задачи, так и осталась. То есть, функциональный тест не должен был упасть.

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РЕШЕНИЕ⇩**

============



```poetry
li:nth-child(2) .destroy
```



==========================================

### Хрупкие строгие локаторы. Избыточность в путях – привязка к точному пути {#fragile-strict-locators-binding-to-exact-path}

Допустим, у нас есть элементы:

```html
<li>
  <div class="crd">
    <label>1</label>
    <input type="button" class="destroy"/>
  </div>
  ...
</li>
<li>
  <div class="crd">
    <label>2</label>
    <input type="button" class="destroy"/>
  </div>
  ...
</li>
...
```

Тогда следующий селектор, вероятно, будет «хрупким»:

```poetry
li:nth-child(2)**>div>**.destroy
```


С развитием проекта внутренняя структура html может усложняться. И там, где сейчас у нас есть два «родительских элемента», по отношению к тому элементу, что мы ищем:

```html
<li>
  <div class="crd">
    <label>2</label>
    <input type="button" class="destroy"/>
  </div>
  ...
</li>
```

со временем может появиться 3:

```html
<li>
  <div>
    <div class="crd">
      <label>2</label>
      <input type="button" class="destroy"/>
    </div>
  </div>
  ...
</li>
```

В таком случае наш селектор перестанет работать и тест упадет. Хотя функционал, по сути, не поменялся – как была кнопка удаления задачи, так и осталась. То есть, функциональный тест не должен был упасть.

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РЕШЕНИЕ⇩**

============



```poetry
li:nth-child(2) .destroy
```


====================================================

### Хрупкие строгие локаторы. Привязка к нумерации «всех детей» (nth-child) {#nth-child-vs-nth-of-type}

```python
element("#todo-list>li:nth-child(2)...").click()
```

… упадет если у `li` появятся новые «сестры» или «братья» другого типа


ПРИМЕР

```html
<ul id="todo-list">
  <li>...a...</li>
  <div>...</div>
  <li>...b...</li>
  ...
</ul>
```

… теперь, после появления нового брата `div` – `li` с `b` уже не есть 2-ым ребенком в семье родителя `#todo-list` ;)

[Поищи](https://www.w3schools.com/csSref/css_selectors.asp) какие там еще есть способы выбора элемента по номеру в CSS-селекторах;)

,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РЕКОМЕНДАЦИИ⇩**

=============



* в зависимости что ты выберешь – `nth-child` или `nth-of-type` – селектор может стать более хрупким
* загугли насчет разницы и всегда выбирай менее хрупкий способ в твоем контексте
  * [гугл](https://www.google.com/search?q=nth-child+vs+nth-of-type&oq=nth-child+vs+nth-of-type&aqs=chrome..69i57j0l2j69i60.10456j0j1&sourceid=chrome&ie=UTF-8) видаст тебе что-то [такое](https://css-tricks.com/the-difference-between-nth-child-and-nth-of-type/) или [такое](https://bitsofco.de/nth-child-vs-nth-of-type/)



,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РЕШЕНИЕ⇩**

=============



```python
element("#todo-list>li:nth-of-type(2)...").click()
```

… не зависит от другого типа элементов, что могут появиться между элементами `li` на том же уровне вложенности, и поэтому есть менее хрупким и более стабильным.


==========================

### Хрупкие строгие локаторы. Привязка либо к полному значению атрибута class, либо его начала или конца {#fragile-strict-locators-binding-to-full-class-attribute-or-its-parts}

Допустим, у нас есть элементы:

```html
<li class="end">1</li>
<li class="middle end">2</li>
<li class="end">3</li>
```

И нам нужно уметь отдельно находить второй элемент (с текстом 2) и отдельно оба – первый (1) и третий (3). Мы можем увидеть, что их отличает значение атрибута `class`. У второго элемента это значение начинается с текста `"middle"`, а у первого и третьего – целое значение равно `"end"`.

Следовательно, мы можем построить и локаторы соответственно:

* найти элемент(ы), у которого значение атрибута класс начинается с текста `"middle"`

```poetry
[class**^=**"middle"]
```

* найти элемент(ы), у которого целое значение атрибута класс равно тексту `"end"`

```poetry
[class**=**"end"]
```

Аналогичные примеры будут и для XPATH селекторов. Иногда такой подход – единственное, что остается. Но в случае, когда мы работаем с атрибутом `class`, стоит быть осторожным.  Дело в том, что новые CSS классы склонны появляться у элементов время от времени. И если, как в примере выше, мы намертво привяжемся к полному значению атрибута `class`, либо, его началу, то если вдруг программисты решат повесить на наши элементы еще один css-класс, например `"start"`:

```html
<li class="start end">1</li>
<li class="start middle end">2</li>
<li class="start end">3</li>
```

то наши локаторы «сломаются» и перестанут находить нужные нам элементы. При этом фича, которую мы должны были покрывать в нашем тесте, где мы использовали эти локаторы, все еще должна работать, и, соответственно, результат теста будет не показательным с точки зрения его «цели тестирования». Такая [хрупкость локаторов может быть нежелательна](#strict-or-stable-locators) на проектах, где могут иметь место частые изменения такого вида. В таких случаях стоит поискать более «гибкий» и «стабильный» локатор.

Обычно можно построить локатор через поиск по вхождению определенного текста в значение атрибута, или даже по вхождению «слова» в значение атрибута. В CSS селекторах конкретно в случае поиске по CSS классу для этого даже есть специальное сокращение. Когда же нужно исключить из поиска элементы со значением атрибутов, имеющим определенные слова – для этого и в CSS и XPATH селекторах есть соответствующие модификаторы поиска.

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РЕШЕНИЕ⇩**

============



* найти второй элемент

```poetry
[class**~=**"middle"]
```

или лучше:

```poetry
**.**middle
```

* найти все элементы кроме второго

```poetry
**:not(.**middle**)**
```



=========================

### Хрупкие гибкие локаторы. Привязка к частичному значению атрибута class {#fragile-flexible-locators-binding-to-partial-class-attribute}

Иногда с «гибкостью» локаторов можно перестараться, и в результате получится не [стабильный а хрупкий локатор](#strict-or-stable-locators).

Допустим, у нас есть html-код:

```html
<li class="foo bar">1</li>
<li class="foo">2</li>
<li class="foo bar">3</li>
```

Нам нужно уметь находить элементы с классом `bar`. И вот мы строим наш локатор по принципу:

* найти элемент(ы), у которых значение атрибута `class` содержит (contains) текст `"bar"`.

```poetry
[class*="bar"]
```

И тут девелоперы в какой-то момент осознали, что есть особенный вид элементов `foobar` (привет утконосам из Австралии;))...

```html
<li class="foo bar">1</li>
<li class="foo">2</li>
<li class="foo bar">3</li>
<li class="foobar">4</li>
```

И вуаля, локатор, который был предназначен для нахождения только элементов `"bar"`, теперь находит и элементы `"foobar"`.

Поэтому когда мы работаем с определением элементов исходя из значений атрибута class – обычно лучше искать «по CSS class-у», то есть вхождению соответствующего «**целого** слова» в значение атрибута (учти, что *СSS class* – это одно из слов в значении атрибута `class`, а *class* – это имя одноименного атрибута)

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РЕШЕНИЕ⇩**

============

```poetry
[class~='bar']
```

или еще лучше – лаконичней и читабельней, учитывая что в случае вхождения слов именно в атрибут class – существует всем известный стандартный «шорткат»:

```poetry
.bar
```



=======================================

### Построение локатора с помощью менее читабельных и понятных атрибутов либо их значений {#building-locators-with-notreadable-attributes-or-their-values}

*Пример*

```poetry
elements("#todo-list li**[class='ember-view']**").shouldHave(exactTexts("a", "c"));
```

Главная проблема в этом коде – это [потенциальная хрупкость локатора](#strict-or-stable-locators), как следствие [привязки к целому значению атрибута class](#fragile-strict-locators-binding-to-full-class-attribute-or-its-parts).

Но есть и другая ошибка. Для построения локатора было выбрано значение `"ember-view"`, которое абсолютно ничего не говорит о том, о чем этот локатор. Этот локатор должен искать «активные задачи». А ищет какие-то «задачи с ember-view `о_О`». Иногда выбора нет, и более понятный локатор не построишь. Тогда, чтобы [код все еще был понятным, и его было просто поддерживать в будущем](https://en.wikipedia.org/wiki/Self-documenting_code), [используют переменные с более четким именем](#when-to-move-locators-to-vars). Но в этом случае можно подобрать намного более читабельный и даже более лаконичный локатор.

,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩Подсказка 1⇩**

===============



Сфокусируйся на том, что «должен найти локатор». А найти он должен «активные задачи». Каким другим способом можно перефразировать «активность» задачи?

,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩Подсказка 2⇩**

===============

В этом случае можно построить более простой локатор исходя из того, что «активные задачи» – это тоже самое, что **«незавершенные задачи»**.

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РЕШЕНИЕ⇩**

============



```poetry
elements("#todo-list li**:not(.completed)**").shouldHave(exactTexts("a", "c"));
```



==============================================

### Слишком краткие и потому менее информативные, неочевидные локаторы {#over-concised-locators}

Часто, с целью сделать локатор покороче, мы не учитываем того, что краткость может навредить читабельности и сделать тесты более сложными в восприятии (мы еще вернемся к этой теме в следующих уроках – [смотри раздел о читабельности и лаконичности...](./01-01-L-poc.md#tests-fast-in-impl-readability-and-conciseness))

Если тест откроет человек, который его не писал, и увидит там код с локатором вида:

*Пример 1*

```poetry
element("**li**:nth-child(2) .toggle").click();
```

... ему может быть не очевидно что `li` это элемент списка задач а не какого то другого списка.

В следующем коде также «идет речь об элементах списка задач», но при этом локатор никак об этом не «информирует»:

*Пример 2*

```poetry
elements(**"**.completed").shouldHave(exactTexts("b"));
```

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РЕШЕНИЕ⇩**

============



*Пример 1*

```poetry
element("**#todo-list **li:nth-child(2) .toggle").click();
```



*Пример 2*

```poetry
elements("**#todo-list li**.completed").shouldHave(exactTexts("b"));
```



=======================================

### Неконсистентные селекторы {#notconsistent-selectors}

*Пример*

```poetry
//...
elements("**#todo-list li**").shouldHave(exactTexts("a", "b", "c"));

element("**#todo-list>li**:nth-of-type(2) .toggle").click();
//...
```

Важно быть как можно более последовательным и единообразным в построении локаторов. Потому что чем больше мы сделаем код «разнообразным» – тем сложнее его будет понимать другим, тем менее читабельными будут тесты, тем больше у других членов команды будет уходить времени на поддержку тестов. А в тестах очень важна читабельность, учитывая то, что их очень много, их пишут разные люди и когда тесты падают – нужно как можно быстрее понять что произошло, найти и разобраться с причиной.

В коде выше для нахождения одних и тех же сущностей – элементов задач – используются разные селекторы:

* `#todo-list li` (ищет все элементы `li` внутри элемента `#todo-list` на любой глубине вложенности)
* `#todo-list>li` (ищет все элементы `li` внутри элемента `#todo-list` на первом уровне вложенности)

Это будет сбивать с толку во время разбора кода теста тех, кто его не писал. Ведь первый сигнал, который поступит в мозг от глаз, будет – «это разные селекторы». И только потом, затратив время на обработку, мозг поймет, что это один и тот же селектор. Зачем же утруждать его лишней работой? ;)

Еще один минус в том, что при глобальной замене этой части селектора на какую-то другую, не получится заменить все вхождения сразу, как раз за счет того, что эти части селектора – неконсистентны. Конечно, можно сказать, что если бы мы вынесли эту часть в переменную, то и проблемы такой бы не было. Но контексты могут быть разными на разных проектах, и [не всегда может быть полезно использовать переменные](#when-to-move-locators-to-vars).

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РЕШЕНИЕ⇩**

============



либо:

```poetry
//...
elements("**#todo-list>li**").shouldHave(exactTexts("a", "b", "c"));

element("**#todo-list>li**:nth-of-type(2)").element(".toggle").click();
//...
```

либо:

```poetry
//...
elements("**#todo-list li**").shouldHave(exactTexts("a", "b", "c"));

element("**#todo-list li**:nth-of-type(2)").element(".toggle").click();
//...
```

Первый вариант более строгий, поэтому если на проекте велика вероятность, что появятся другие элементы `li` внутри `#todo-list` (например глубже...), то такой селектор будет менее «стабильным».

Второй вариант менее строгий, поэтому если вдруг текущие элементы `li` вследствие каких-то изменений «опустятся ниже» – он все еще будет работать. Такой селектор может быть более «стабильным» и «живучим».

Лучший вариант выбрать между двух невозможно, все зависит от проекта ;) Но можно начать с второго, а там видно будет ;)



*Другие примеры ошибок...*

```poetry
elements("#todo-list li").shouldHave(exactTexts("a", "b", "c"));
element("li:nth-child(2) .toggle").click();
element(".completed").shouldHave(exactText("b"));
elements("#todo-list [class|=ember-view]").shouldHave(exactTexts("a", "c"));
```

Определившись с локатором для поиска «лист-айтема» (`li`) списка задач (`todo-list`):

```poetry
elements("**#todo-list li**").shouldHave(exactTexts("a", "b", "c"));
```

... уже в следующей строке кода для отображения того же самого элемента списка мы используем другой, пускай более короткий, но «неконсистентный» и менее информативный локатор:

```poetry
element(**"li**:nth-child(2) .toggle").click();
```

... а теперь мы вообще забыли хоть как то упомянуть в локаторе о том что мы работаем с задачами:

```poetry
element(**"**.completed").shouldHave(exactText("b"));
```

... и последней вишенькой на тортике, мы решили «для разнообразия» в этот раз опустить `li`

```poetry
elements("#todo-list** [**class|=ember-view]").shouldHave(exactTexts("a", "c"));
```

А здесь кто-то решил побеспокоится о других разработчиках, которые этот код не писали, чтобы сразу как только они открыли код упавшего теста – глаза сразу увидели сквозь весь код, в каких строчках ведется работа с одними и теми же сущностями – `todo-list li`:

```poetry
elements("**#todo-list li**").shouldHave(exactTexts("a", "b", "c"));
element("**#todo-list li**:nth-child(2) .toggle").click();
element("**#todo-list li**.completed").shouldHave(exactText("b"));
elements("**#todo-list li***[class|=ember-view]*").shouldHave(exactTexts("a", "c"));
```

При этом одна ошибка все еще осталась в последней строке (выделенная курсивом), [но о ней в другой раз;)](#building-locators-with-notreadable-attributes-or-their-values)



===========

### Фэншуй {#feng-shui}

Есть в программировании вещи, которые могут показаться неоправданными усилиями ради какого-то «сомнительного фэншуя». Например «отступы в коде», «дополнительные пустые строчки», подбор читабельных понятных имен, и т. д. Но, на самом деле, чем больше растет количество написанного кода в проекте, тем он более становится похожим на сложный организм человека, в котором при проведении операций хирургу непростительно быть «неаккуратным», да и операции проще проводить в теле с более-менее хорошим состоянием. Поэтому стоит задуматься о том, чтобы выработать у себя некоторые «задротские, но здоровые привычки» ;)



=======================================================

### Фэншуй. Неравномерные отступы в коде {#feng-shui-unaligned-code-indentation}

```poetry
public class TodoMvcTest {

    @Test
_  _void completesTodo() {
        open("http://todomvc.com/examples/emberjs");

        //...code

        _  _//...code
  _ _}
_  _}
```

Отступы в коде помогают отобразить его вложенную структуру – выделить соответвующие блоки кода, которые отображают определенный контекст, например: тест-суит (тест-класс), тест-кейс (тест-метод), и т. д. Если же не следить за правильными отступами – код станет плохо читаемым, что сильно затруднит его понимание и поддержку.

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РЕШЕНИЕ⇩**

============



```poetry
public class TodoMvcTest {

    @Test
    void completesTodo() {
        open("http://todomvc.com/examples/emberjs");

        //...code

        //...code
    });
});
```



===========================================

### Фэншуй. Лишние пустые строки {#feng-shui-redundant-empty-lines}

```poetry
public class TodoMvcTest {

_ _
    @Test
    void completesTodo() {
        open('http://todomvc.com/examples/emberjs');

        //...code

        //...code
_ _
    }
_ _
_ _
}
```

Лишние пустые строки, на первый взгляд, достаточно безобидны, но если их использовать «с умом» – то с их помощью можно также выделять структуру в коде, например – блоки связанных шагов и проверок в коде тест-метода (~ «тест-кейса»). Да и основные части кода, такие как методы – также удобно отделять друг от друга пустыми строками, для «усиления» выразительности кода. И если где-то их использовать «с умом», а где-то «как попало», то от «усилий ума» толку не будет никакого;)

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РЕШЕНИЕ⇩**

============



```poetry
public class TodoMvcTest {

    @Test
    void completesTodo() {
        open('http://todomvc.com/examples/emberjs');

        //...code

        //...code
    }
}
```

</ru>

<uk>

### Структурна інформація в іменах тест-суіта та тестів, яка не несе користі з точки зору тестування {#structural-info-in-test-names}

*Приклад 1*

```poetry
public class TodoMvc**CssVersionTest** {

    @Test
    void completesTodo() {
```

*Приклад 2*

```poetry
public class TodoMvcTest {

    @Test
    void completesTodo**CssVersion** {
```

Імена тест-класу і тест-методу грають, по суті, роль імен «тест-суіта» і «тест-кейса» відповідно, а останні – повинні показувати те, що ми тестуємо, а не, наприклад, «нюанси реалізації», як у вищезгаданих прикладах. Якщо ж є бажання структурувати свій розв'язок для завдань – краще створити окремі папки і розкласти в них, як по поличках – різні версії розв'язків.

*Наприклад, так... (шукай розв'язок далі)*

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ’ЯЗОК⇩**

============

```poetry
selenide-intro/
  src/
    test/
      java/
        com/
          yashaka/
            selenideintro/
              **csstodo**/
                TodoMvcTest.java
              **xpathtodo**/
                TodoMvcTest.java
```

==============================================================

### Невідповідність імен тест-суіта або тест-кейсів цілям тестування {#describe-and-it-names-does-not-reflect-test-goals}

*Приклад 1*

```poetry
public class TodoMvcTest {

    //...

    @Test
    void **testTodoMvc**() {
```

*Приклад 2*

```poetry
public class TodoMvc**Completes**Test {

    //...

    @Test
    void completes() {
```

Імена тест-класу і тест-методу грають, по суті, роль імен «тест-суіта» і «тест-кейса» відповідно, а останні – повинні показувати те, що ми тестуємо. У першому прикладі вище ім'я тест-методу не несе зовсім ніякої корисної інформації з точки зору цілей тестування для нашого сценарію. У другому прикладі ім'я тест-класу недостатньо абстрактно в контексті нашого покриття (ми якраз «завершення» завдання покриваємо в тест-методі).

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ’ЯЗОК⇩**

============

```poetry
public class **TodoMvcTest** {

    //...

    @Test
    void **completesTodo**() {
```

========================================================

### Встановлення шляху до chromedriver в коді {#setting-path-to-chromedriver-in-the-code}

*Приклад*

```poetry
System.setProperty("webdriver.chrome.driver", "**C:/work/web drivers/chromedriver.exe**");
```

Зазвичай, набагато простіше і універсальніше **прописати шлях до chromedriver в системну змінну оточення PATH** (можливо, щоб зміни набрали чинності, доведеться перезавантажити OS). Такий розв'язок краще з тієї причини, що тести можуть бути запущені на різних машинах, і якщо ми пропишемо точний шлях в коді тестів до chromedriver – нам доведеться на всіх машинах підганяти розташування драйвера до цього шляху. А що робити, якщо ми захочемо запустити тести під інший OS, де і шляхи-то можуть бути зовсім в іншому форматі? ;) Тому краще перекласти відповідальність за «встановлення шляху драйвера» з коду тестів на конфігурації машин для запуску тестів.

Як встановити PATH? – можна загуглити розв'язок конкретно під потрібну OS;)

===========================================================
### Використання «заборонених у завданні методів Selenide» {#using-todo-forbidden-selenide-methods}

*Приклад*

```poetry
element("#todo-list>li:nth-child(2)")**.find(**".toggle"**)**.click();
```

В цьому завданні ми вчимося знаходити елементи лише силами CSS. В завданнях вказано, які типи методів не можна використовувати;)

В прикладі вище був використаний метод `SelenideElement#find` (метод `find`, визваний для об'єкта класу `SelenideElement`, який вертає статичний метод `element` класу Selenide), він дозволяє знайти внутрішній елемент по селектору всередині другого, а наша задача – навчитись такому «внутрішньому пошуку» лише за допомогою CSS селекторів в цьому завданні;)

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ’ЯЗОК⇩**

============

```poetry
element("#todo-list>li:nth-child(2) .toggle").click();
```

======================================

### Крихкі жорсткі локатори {#fragile-strict-locators}

Зазвичай є кілька способів написати локатор щоб знайти один той же елемент на сторінці. Можна використовувати дуже багато інформації про структуру html (вкладеність елементів, порядок їх слідування один за іншим) і змісті (тексти, значення атрибутів елементів) і тоді вийде «жорсткий» локатор. Або використовувати мінімум інформації – і тоді вийде «слабкий» або «гнучкий» локатор. У наступній серії помилок ми розглянемо типові випадки, коли [жорсткі локатори призводять до нестабільних «крихких» тестів](#strict-or-stable-locators) (flaky tests).

======================================

### Крихкі жорсткі локатори. Надмірність в шляхах – прив'язка до тегу {#fragile-strict-locators-binding-to-tag}

Допустимо, у нас є елементи:

```html
<li>
  <div class="crd">
    <label>1</label>
    <input type="button" class="destroy"/>
  </div>
  ...
</li>
<li>
  <div class="crd">
    <label>2</label>
    <input type="button" class="destroy"/>
  </div>
  ...
</li>
...
```

Тоді наступний селектор, ймовірно, буде «крихким»:

```poetry
li:nth-child(2) **input**.destroy
```

Для точного визначення елементів кращою практикою в розробці внутрішнього уявлення html сторінок заведено використовувати атрибути елементів, в більшості випадків – `id` (для визначення унікальних елементів) і `class` (для визначення групи однотипних елементів). Тому використовувати теги елементів, особливо коли елемент можна визначити по css класу – менш переважно. У нашому випадку внутрішня реалізація може, наприклад, помінятися від:

```html
    <input type="button" class="destroy">
```
до
```html
    <button class="destroy"></button>
```

У такому випадку наш селектор перестане працювати і тест впаде. Хоча функціонал, по суті, не змінився – як була кнопка видалення завдання, так і залишилася. Тобто, функціональний тест не повинен був впасти.

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ’ЯЗОК⇩**

============

```poetry
li:nth-child(2) .destroy
```

============================================================

### Крихкі жорсткі локатори. Надмірність в шляхах – прив'язування до точного шляху {#fragile-strict-locators-binding-to-exact-path}

Допустимо, у нас є елементи:

```html
<li>
  <div class="crd">
    <label>1</label>
    <input type="button" class="destroy"/>
  </div>
  ...
</li>
<li>
  <div class="crd">
    <label>2</label>
    <input type="button" class="destroy"/>
  </div>
  ...
</li>
...
```

Тоді наступний селектор, ймовірно, буде «крихким»:

```poetry
li:nth-child(2)**>div>**.destroy
```


З розвитком проекту внутрішня структура html може ускладнюватися. І там, де зараз у нас є два «батьківських елемента», стосовно до того елемента, що ми шукаємо:

```html
<li>
  <div class="crd">
    <label>2</label>
    <input type="button" class="destroy"/>
  </div>
  ...
</li>
```

з часом може з'явитися 3:

```html
<li>
  <div>
    <div class="crd">
      <label>2</label>
      <input type="button" class="destroy"/>
    </div>
  </div>
  ...
</li>
```

У такому випадку наш селектор перестане працювати і тест впаде. Хоча функціонал, по суті, не змінився – як була кнопка видалення завдання, так і залишилася. Тобто, функціональний тест не повинен був впасти.

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ’ЯЗОК⇩**

============

```poetry
li:nth-child(2) .destroy
```



====================================================

### Крихкі жорсткі локатори. Прив'язка до нумерації «усіх дітей»  (nth-child) {#nth-child-vs-nth-of-type}

```python
element("#todo-list>li:nth-child(2)...").click()
```

… впаде якщо у `li` з’являться нові «сестри» чи «брати» іншого типу


ПРИКЛАД

```html
<ul id="todo-list">
  <li>...a...</li>
  <div>...</div>
  <li>...b...</li>
  ...
</ul>
```

… тепер, після появи нового брата `div` – `li` з `b` вже не є 2-гою дитиною в сім’ї батька `#todo-list` ;)

[Пошукай](https://www.w3schools.com/csSref/css_selectors.asp) які там ще є способи вибору елемента по номеру в CSS-селекторах;)

,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩ПОРАДИ⇩**

=============



* в залежності що ти вибереш – `nth-child` чи `nth-of-type` – селектор може стати більш крихким
* загугли щодо різниці і завжди обирай менш крихкий спосіб у твоєму контексті
  * [гугл](https://www.google.com/search?q=nth-child+vs+nth-of-type&oq=nth-child+vs+nth-of-type&aqs=chrome..69i57j0l2j69i60.10456j0j1&sourceid=chrome&ie=UTF-8) видасть тобі щось [таке](https://css-tricks.com/the-difference-between-nth-child-and-nth-of-type/) чи [таке](https://bitsofco.de/nth-child-vs-nth-of-type/)



,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ'ЯЗОК⇩**

=============



```python
element("#todo-list>li:nth-of-type(2)...").click()
```

… не залежить від іншого типу елементів що можуть з’явитись поміж елементів `li` на тому самому рівні вкладеності, а тому є менш крихким і більш стабільним.



================================================================

### Крихкі жорсткі локатори. Прив'язка або до повного значенням атрибута class, або його початку або кінця {#fragile-strict-locators-binding-to-full-class-attribute-or-its-parts}

Допустимо, у нас є елементи:

```html
<li class="end">1</li>
<li class="middle end">2</li>
<li class="end">3</li>
```

І нам потрібно вміти окремо знаходити другий елемент (з текстом 2) і окремо обидва – перший (1) і третій (3). Ми можемо побачити, що їх відрізняє значення атрибута `class`. У другого елементу це значення починається з тексту `" middle "`, а у першого і третього – ціле значення дорівнює `" end "`.

Отже, ми можемо побудувати і локатори відповідно:
- знайти елемент(и), у якого значення атрибута клас начинається з тексту `"middle"`

```poetry
[class**^=**"middle"]
```

- знайти елемент(и), у якого ціле значення атрибута клас рівне тексту `"end"`

```poetry
[class**=**"end"]
```

Аналогічні приклади будуть і для XPATH селекторів. Іноді такий підхід – єдине, що залишається. Але в разі, коли ми працюємо з атрибутом `class`, варто бути обережним. Річ в тому, що нові CSS класи схильні з'являтися у елементів час від часу. І якщо, як в прикладі вище, ми намертво прив'яжемося до повного значенням атрибута `class`, або, його початку, то якщо раптом програмісти вирішать повісити на наші елементи ще один css-клас, наприклад` "start" `:

```html
<li class="start end">1</li>
<li class="start middle end">2</li>
<li class="start end">3</li>
```

то наші локатори «зламаються» і перестануть знаходити потрібні нам елементи. При цьому фіча, яку ми повинні були покривати в нашому тесті, де ми використовували ці локатори, все ще має працювати, і, відповідно, результат тесту буде не показовим з точки зору його «цілі тестування». Така [крихкість локаторів може бути небажана] (# strict-or-stable-locators) на проектах, де можуть мати місце часті зміни такого виду. У таких випадках варто пошукати більш «гнучкий» і «стабільний» локатор.

Зазвичай можна побудувати локатор через пошук по входженню певного тексту в значення атрибуту, або навіть по входженню «слова» в значення атрибуту. В CSS селекторах конкретно в разі пошуку по CSS класу для цього навіть є спеціальне скорочення. Коли ж потрібно виключити з пошуку елементи зі значенням атрибутів, які мають певні слова – для цього і в CSS і XPATH селекторах є відповідні модифікатори пошуку.

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ’ЯЗОК⇩**

============

– знайти другий елемент

```poetry
[class**~=**"middle"]
```

або краще:

```poetry
**.**middle
```

– знайти всі елементи окрім другого

```poetry
**:not(.**middle**)**
```



==============================================================

### Крихкі гнучкі локатори. Прив'язка до часткового значення атрибута class {#fragile-flexible-locators-binding-to-partial-class-attribute}

Іноді з «гнучкістю» локаторів можна перестаратися, і в результаті вийде не [стабільний а крихкий локатор](#strict-or-stable-locators).

Допустимо, у нас є html-код:

```html
<li class="foo bar">1</li>
<li class="foo">2</li>
<li class="foo bar">3</li>
```

Нам потрібно вміти знаходити елементи з класом `bar`. І ось ми будуємо наш локатор за принципом:

- знайти елемент(и), у яких значення атрибута `class` містить (contains) текст `"bar"`.

```poetry
[class*="bar"]
```

І тут девелопери в якийсь момент усвідомили, що існує особливий вид елементів `foobar` (привіт качконосам із Австралії;))...

```html
<li class="foo bar">1</li>
<li class="foo">2</li>
<li class="foo bar">3</li>
<li class="foobar">4</li>
```

І вуаля, локатор, який був призначений для знаходження тільки елементів `"bar"`, тепер знаходить і елементи `"foobar"`.

Тому коли ми працюємо з визначенням елементів виходячи із значень атрибута `class` – зазвичай краще шукати «по CSS-класу», тобто входженню відповідного «**цілого** слова» в значення атрибута (врахуй, що *СSS-клас* – це одне зі слів (відокремлених пробілами) в значенні атрибуту `class`, а *class* – це ім'я одноіменного атрибута)

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ’ЯЗОК⇩**

============

```poetry
[class**~=**'bar']
```

чи ще краще – лаконічніше та читабельніше, враховуючи, що у випадку входження слів саме в атрибут class – існує всім відомий загальноприйнятий «шорткат»:

```poetry
**.**bar
```

==============================================================

### Побудова локатора за допомогою менш читабельних і зрозумілих атрибутів або їх значень {#building-locators-with-notreadable-attributes-or-their-values}

*Приклад*

```poetry
elements("#todo-list li**[class='ember-view']**").shouldHave(exactTexts("a", "c"));
```

Головна проблема в цьому коді – це [потенційна крихкість локатора](#strict-or-stable-locators), як наслідок [прив'язки до цілого значення атрибуту class](#fragile-strict-locators-binding-to-full-class-attribute-or-its-parts).

Та є й інша помилка. Для побудови локатора було вибране значення `"ember-view"`, яке абсолютно нічого не каже про що цей локатор. Цей локатор має шукати «активні задачі». А шукає якісь «задачі з ember-view `о_О`». Більш того, наш додаток побудований на основі фронтенд-фреймворку EmberJs (згадай, яким був URL, по якому ми відкривали додаток). Знаючи це можна здогадатися, що цей CSS-класс `ember-view` ще й скоріше за все автозгенерований ... А все, що генерується автоматично і, по суті, є «динамічно змінним» – явно не є тим, що буде «стабільним», а значить і не є тим, на що можна покластися при побудові стабільного «не крихкого» локатора.  Інколи вибору немає, і больш зрозумілий локатор не побудуєш. Тоді, щоб [код все ще був зрозумілим, і його було просто підтримувати в майбутньому](https://en.wikipedia.org/wiki/Self-documenting_code), [використовують змінні з чіткішим іменем](#when-to-move-locators-to-vars). Але в цьому випадку можна підібрати набагато читабельніший і навіть більш лаконічний локатор. Також не забуваємо, що в цьому завданні ми не використовуємо конструкції типу змінних або функцій;)

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩Підказка⇩**

============

Сфокусуйся на тому, що «повинен знайти локатор». А знайти він має «активні задачі». Яким іншим способом можна перефразувати «активність» задачі?

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩Ще підказка⇩**

============

В цьому випадку можна побудувати більш стабільний і простий локатор виходячи з того, що «активні задачі» – це те ж саме, що **«незавершені задачі»**.

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ’ЯЗОК⇩**

============

```poetry
elements("#todo-list li**:not(.completed)**").shouldHave(exactTexts("a", "c"));
```

=======================================================

### Занадто короткі і тому менш інформативні, неочевидні локатори {#over-concised-locators}

Часто, з ціллю зробити локатор коротше, ми не враховуємо того, що стислість може нашкодити читабельності і зробити тести складнішими в сприйнятті (ми ще повернемось до цієї теми в наступних уроках – [дивись розділ про читабельність і лаконічність...](./01-01-L-poc.md#tests-fast-in-impl-readability-and-conciseness))

Якщо тест відкриє людина, яка його не писала, і побачить там код з локатором виду:

*Приклад 1*

```poetry
element("**li**:nth-child(2) .toggle").click();
```

... йому може бути не очевидно, що `li` – це елемент списку задач, а не якого-небудь іншого списку.

В наступному коді також «йде річ про елементи списку задач», але при цьому локатор ніяк про це не «інформує»:

*Приклад 2*

```poetry
elements(**"**.completed").shouldHave(exactTexts("b"));
```

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ’ЯЗОК⇩**

============

*Приклад 1*

```poetry
element("**#todo-list **li:nth-child(2) .toggle").click();
```

*Приклад 2*

```poetry
elements("**#todo-list li**.completed").shouldHave(exactTexts("b"));
```

=======================================

### Неконсистентні селектори {#notconsistent-selectors}

*Приклад*
```poetry
//...
elements("**#todo-list li**").shouldHave(exactTexts("a", "b", "c"));

element("**#todo-list>li**:nth-of-type(2) .toggle").click();
//...
```

Важливо бути якомога послідовнішим та одноманітнішим в побудові локаторів. Тому що чим більше ми зробимо код «різноманітним» – тим складніше його буде розуміти іншим, тим менш читабельними будуть тести, тим більше в інших членів команди буде затрачатись часу на підтримку тестів. А в тестах дуже важлива читабельність, враховуючи те, що їх дуже багато, їх пишуть різні люди і коли тести падають – потрібно якомога швидше зрозуміти що сталось, знайти та розібратися з причиною.

В коді вище для знаходження одних і тих же сутностей – елементів задач – використовуються різні селектори:
- `#todo-list li` (шукає всі елементи `li` всередині елементу `#todo-list` на любій глибині вкладеності)
- `#todo-list>li` (шукає всі елементи `li` всередині елементу `#todo-list` на першому рівні вкладеності)

Це буде збивати з пантелику під час розбору коду тесту тих, хто його не писав. Адже перший сигнал, який поступить в мізки від очей, буде – «це різні селектори». І лише потім, затративши час на обробку, мозок зрозуміє, що це один і той же селектор. Навіщо ж обтяжувати його лишньою роботою? ;)

Ще один мінус в тому, що при глобальній заміні цієї частини селектора на яку-небудь іншу, не вийде замінити всі входження відразу, як раз внаслідок того, що ці частини селектора – неконсистентні. Звичайно, можна сказати, що якби ми винесли цю частину в змінну, то і проблеми такої б і не було. Але контексти можуть бути різними на різних проектах, і [не завжди може бути корисно використовувати змінні](#when-to-move-locators-to-vars). І знову ж таки, в момент коли ми захочемо виділити нову змінну – нам буде важко це зробити, тому що глобальна заміна не спрацює у всіх випадках.

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ’ЯЗОК⇩**

============

або:

```poetry
//...
elements("**#todo-list>li**").shouldHave(exactTexts("a", "b", "c"));

element("**#todo-list>li**:nth-of-type(2)").element(".toggle").click();
//...
```

або:

```poetry
//...
elements("**#todo-list li**").shouldHave(exactTexts("a", "b", "c"));

element("**#todo-list li**:nth-of-type(2)").element(".toggle").click();
//...
```

Перший варіант більш жорсткий, тому якщо на проекті велика ймовірність, що з'являться інші елементи `li` всередині `#todo-list` (наприклад глибше...), то такий селектор буде менш «стабільним».

Другий варіант менш жорсткий, тому якщо раптом поточні елементи `li` внаслідок якихось змін «опустяться нижче» – він все ще буде працювати. Такий селектор може бути «стабільнішим» і «живучішим».

Кращий варіант вибрати між двох неможливо, все залежить від проекту ;) Але можна розпочати з якогось одного, а там видно буде ;)

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩Ще приклади...⇩**

============

```poetry
elements("#todo-list li").shouldHave(exactTexts("a", "b", "c"));
element("li:nth-child(2) .toggle").click();
element(".completed").shouldHave(exactText("b"));
elements("#todo-list [class|=ember-view]").shouldHave(exactTexts("a", "c"));
```

Визначившись з локатором для пошуку «ліст-айтема» (`li`) списку задач (`todo-list`):

```poetry
elements("**#todo-list li**").shouldHave(exactTexts("a", "b", "c"));
```

... вже в наступному рядку коду для відображення того ж самого елементу списку ми використовуємо інший, нехай більш короткий, проте «неконсистентний» і менш інформативний локатор:

```poetry
element(**"li**:nth-child(2) .toggle").click();
```

... а тепер ми взагалі забули хоч якось згадати в локаторі про те, що ми працюємо із задачами:

```poetry
element(**"**.completed").shouldHave(exactText("b"));
```

... і останньою вишенькою на тортику, ми вирішили «для різноманітності» в цей раз опустити `li`

```poetry
elements("#todo-list** [**class|=ember-view]").shouldHave(exactTexts("a", "c"));
```

А тут хтось вирішив потурбуватися про інших разробників, котрі цей код не писали, щоб як тільки вони відкрили код  тесту, що впав – очі відразу побачили через весь код, в яких рядках ведеться робота з одними і тими ж сутностями – `todo-list li`:

```poetry
elements("**#todo-list li**").shouldHave(exactTexts("a", "b", "c"));
element("**#todo-list li**:nth-child(2) .toggle").click();
element("**#todo-list li**.completed").shouldHave(exactText("b"));
elements("**#todo-list li***[class|=ember-view]*").shouldHave(exactTexts("a", "c"));
```

При цьому одна помилка все ще залишилась в останньому рядку (виділена курсивом), [але про неї в інший раз;)](#building-locators-with-notreadable-attributes-or-their-values)

=====================

### Феншуй {#feng-shui}

Існують в програмуванні речі, котрі можуть здатися невиправданими зусиллями заради якогось «сумнівного феншую». Наприклад «відступи в коді», «додаткові пусті рядки», підбір читабельних зрозумілих імен, і т.д. Але, насправді, чим більше росте кількість написаного коду в проекті, тим він більше стає схожим на складний організм людини, в якому при проведенні операцій хірургу непробачно бути «неохайним», та й операції простіше проводити в тілі з більш-менш хорошим станом. Тому є сенс задуматися про те, щоб напрацювати у себе деякі «задротські, проте здорові звички» ;

===================================================

### Фэншуй. Нерівномірні відступи в коді {#feng-shui-unaligned-code-indentation}

```poetry
public class TodoMvcTest {

    @Test
_  _void completesTodo() {
        open("http://todomvc.com/examples/emberjs");

        //...code

        _  _//...code
  _ _}
_  _}
```

Відступи в коді допомагають відобразити його вкладену структуру – виділити відповідні блоки коду, які відображають певний контекст, наприклад: тест-суіт (тест-клас), тест-кейс (тест-метод), і т.д. Якщо ж не стежити за правильними відступами – код стане погано читабельним, що сильно ускладнить його розуміння і підтримку.

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ’ЯЗОК⇩**

============

```poetry
public class TodoMvcTest {

    @Test
    void completesTodo() {
        open("http://todomvc.com/examples/emberjs");

        //...code

        //...code
    });
});
```

========================================

### Феншуй. Зайві пусті рядки {#feng-shui-redundant-empty-lines}

```poetry
public class TodoMvcTest {

_ _
    @Test
    void completesTodo() {
        open('http://todomvc.com/examples/emberjs');

        //...code

        //...code
_ _
    }
_ _
_ _
}
```

Зайві пусті рядки, на перший погляд, достатньо невинні, але якщо їх використовувати «з розумом» – то за їх допомогою можна також виділяти структуру в коді, наприклад – блоки зв'язаних кроків і перевірок в коді тест-функції (~ «тест-кейсу»). Та й основні частини коду, такі як визначення функцій, – також зручно відділяти один від одного пустими рядками, для «підсилення» виразності коду». І якщо десь їх використовувати «розумно», а десь «як вийде», то від «зусиль розуму» користі не буде ніякої;)

,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ’ЯЗОК⇩**

============

```poetry
public class TodoMvcTest {

    @Test
    void completesTodo() {
        open('http://todomvc.com/examples/emberjs');

        //...code

        //...code
    }
}
```

</uk>

<en>

**<p {{RED}}>Waiting for mistakes to be documented...</p>**

</en>

</java>

<py>

<ru>

#### Структурная информация в именах тест-сьюта и тестов, которая не несет пользы с точки зрения тестирования {#structural-info-in-test-names}

*Пример 1*

```poetry
# tests/test_todomvc_css_version.py
# ...

def test_completes_todo():
```

*Пример 2*

```poetry
# tests/test_todomvc.py
# ...

def test_completes_todo**_css_version**():
```


*Пример 3*

```poetry
# tests/test_todomvc_css_version.py
# ...

class TestTodoMvc**CssVersion**:

    def test_completes_todo():
```

*Пример 4*

```poetry
# tests/test_todomvc.py
# ...

class TestTodoMvc:

    def test_completes_todo**_css_version**():
```

Имена тест-модуля (тест-класса) и тест-функций (тест-методов) играют, по сути, роль имен "тест-сьюта" и "тест-кейсов" соответственно, а последние – должны отображать то, что мы тестируем, а не, например, "нюансы реализации", как в примерах выше. Если хочется структурировать свои решения для заданий – лучше создать отдельные папки (пакеты python) и разложить в них, как по полочкам – разные версии решений.

*Например так... (ищи решение на следующей странице)*

===

... минималистично:


```poetry
selene-intro/
  ...
  tests/
    **css_todo**/
      test_todomvc.py
    **xpath_todo**/
      test_todomvc.py
    test_google.py
    test_todomvc.py
  ...
```

или еще более организованно:

```poetry
selene-intro/
  ...
  tests/
    lesson/
      test_google.py
      test_todomvc.py
    todos/
      **css**/
        test_todomvc.py
      **xpath**/
        test_todomvc.py
  ...
```

или еще и с фокусом на том что мы тестируем (а не на том что "учимся"):

```poetry
selene-intro/
  ...
  tests/
    google/
      ..
    todomvc/
      full_selene_version/
        test_todomvc.py
      **css_version**/
        test_todomvc.py
      **xpath_version**/
        test_todomvc.py
  ...
```

Или еще и избегая тавтологии для большей ясности ;)

```poetry
selene-intro/
  ...
  tests/
    google/
      ..
    todomvc/
      full_selene_version/
        test_operations.py
          ...
          def test_complete_todo()
      **css_version**/
        test_operations.py
      **xpath_version**/
        test_operations.py
  ...
```

===

#### Несоответствие имен тест-сьюта или тест-кейсов целям тестирования {#describe-and-it-names-does-not-reflect-test-goals}

*Пример 1*

```poetry
# tests/test_todomvc.py
# ...
def test_**todomvc**:
```

*Пример 2*


```poetry
# tests/test_todomvc**_compete**.py
# ...
def test_completes_todo:
```

*Пример 3*

```poetry
# tests/test_todomvc.py
# ...
class TestTodoMvc:
    # ...

    def test_**todomvc**:
```

*Пример 4*

```poetry
# tests/test_todomvc.py
# ...
class TestTodoMvc**Completes**:
    # ...

    def test_completes_todo:
```

Имена тест-модуля (тест-класса) и тест-функций (тест-методов) играют, по сути, роль имен "тест-сьюта" и "тест-кейсов" соответственно, а последние – должны отображать то, что мы тестируем. В первом примере выше имя тест-функции не несет совсем никакой полезной информации с точки зрения целей тестирования для нашего сценария. Во втором примере имя тест-модуля недостаточно абстрактно в контексте нашего покрытия (мы как раз "завершение" задачи покрываем в тест-функции). Последние два примера аналогичны первым двум, только в них используется стиль тест-классов/тест-методов вместо тест-модулей/тест-функций.

*Решение*...

===

*Пример 1-2*

```poetry
# tests/test_todomvc.py
# ...
def test_completes_todo:
```

*Пример 3-4*

```poetry
# tests/test_todomvc.py
# ...
class TestTodoMvc:
    # ...

    def test_completes_todo:
```

===

#### Установка пути к chromedriver в коде {#setting-path-to-chromedriver-in-the-code}

*Пример*

```poetry
# ...
from selenium import webdriver

options = webdriver.ChromeOptions
options.binary_location = '/opt/bin/chromedriver'
browser.config.driver = webdriver.Chrome(chrome_options=options)
```

Обычно, намного проще и универсальней **прописать путь к chromedriver в системную переменную окружения PATH** (возможно, чтобы изменения вступили в силу, придется перегрузить OS). Такое решение лучше по той причине, что тесты могут быть запущены на разных машинах, и если мы пропишем точный путь в коде тестов к chromedriver – нам придется на всех машинах подгонять местоположение драйвера к этому пути. А что делать, если мы захотим запустить тесты под другой OS, где и пути-то могут быть совсем в другом формате? ;) Поэтому лучше переложить обязанность за "установку пути драйвера" с кода тестов на конфигурации машин для запуска тестов.

Как установить PATH? – можно загуглить решение конкретно под нужную OS;)

===

#### Использование "запрещенных в задании методов Selene" {#using-todo-forbidden-selene-methods}

*Пример*

```poetry
browser.element('#todo-list>li:nth-child(2)')**.element(**'.toggle'**)**.click()
```

В этом задании мы учимся находить элементы только силами CSS. В заданиях указано, какие типы методов нельзя использовать;)

В примере выше использован метод `Element#element` (метод `element`, вызванный для объекта класса `selene.core.Element`, который возвращает метод `element` объекта `browser`), он позволяет найти внутренний элемент по селектору внутри другого, а наша задача - научиться такому "внутреннему поиску" только с помощью CSS селекторов в этом задании;)

*Решение...*
===

```poetry
browser.element('#todo-list>li:nth-child(2) .toggle').click()
```

===

#### Хрупкие строгие локаторы {#fragile-strict-locators}

Обычно есть несколько способов написать локатор чтобы найти один тот же элемент на странице. Можно использовать очень много информации о структуре html (вложенность элементов, порядок их следования один за другим) и содержании (тексты, значения атрибутов элементов) и тогда получится "строгий" локатор. Или использовать минимум информации - и тогда получится "слабый" или "гибкий" локатор. В следующей серии ошибок мы расcмотрим типичные случаи, когда [строгие локаторы приводят к нестабильным "хрупким" тестам](00-03-01-Q-selene-and-css.md#strict-or-stable-locators) (flaky tests).

#### Хрупкие строгие локаторы. Избыточность в путях - привязка к тегу {#fragile-strict-locators-binding-to-tag}

Допустим, у нас есть элементы:

```html
<li>
  <div class="crd">
    <label>1</label>
    <input type="button" class="destroy"/>
  </div>
  ...
</li>
<li>
  <div class="crd">
    <label>2</label>
    <input type="button" class="destroy"/>
  </div>
  ...
</li>
...
```

Тогда следующий селектор, вероятно, будет "хрупким":

```poetry
li:nth-child(2) **input**.destroy
```

Для точного определения элементов лучшей практикой в разработке внутреннего представления html страниц принято использовать атрибуты элементов, в большинстве случаев - `id` (для определения уникальных элементов) и `class` (для определения группы однотипных элементов). Поэтому использовать теги элементов, особенно когда элемент можно определить по css классу - менее предпочтительно. В нашем случае внутренняя реализация может, например, поменяться от:

```html
    <input type="button" class="destroy">
```
до

```html
    <button class="destroy"></button>
```

В таком случае наш селектор перестанет работать и тест упадет. Хотя функционал, по сути, не поменялся - как была кнопка удаления задачи, так и осталась. То есть, функциональный тест не должен был упасть.

*Решение:*
===

```poetry
li:nth-child(2) .destroy
```

===

#### Хрупкие строгие локаторы. Избыточность в путях - привязка к точному пути {#fragile-strict-locators-binding-to-exact-path}

Допустим, у нас есть элементы:

```html
<li>
  <div class="crd">
    <label>1</label>
    <input type="button" class="destroy"/>
  </div>
  ...
</li>
<li>
  <div class="crd">
    <label>2</label>
    <input type="button" class="destroy"/>
  </div>
  ...
</li>
...
```

Тогда следующий селектор, вероятно, будет "хрупким":

```poetry
li:nth-child(2)**>div>**.destroy
```


С развитием проекта внутренняя структура html может усложняться. И там, где сейчас у нас есть два "родительских элемента", по отношению к тому элементу, что мы ищем:

```html
<li>
  <div class="crd">
    <label>2</label>
    <input type="button" class="destroy"/>
  </div>
  ...
</li>
```

со временем может появиться 3:

```html
<li>
  <div>
    <div class="crd">
      <label>2</label>
      <input type="button" class="destroy"/>
    </div>
  </div>
  ...
</li>
```

В таком случае наш селектор перестанет работать и тест упадет. Хотя функционал, по сути, не поменялся - как была кнопка удаления задачи, так и осталась. То есть, функциональный тест не должен был упасть.

*Решение...*
===

```poetry
li:nth-child(2) .destroy
```

===

#### Хрупкие строгие локаторы. Привязка либо к полному значению атрибута class, либо его начала или конца {#fragile-strict-locators-binding-to-full-class-attribute-or-its-parts}

Допустим, у нас есть элементы:

```html
<li class="end">1</li>
<li class="middle end">2</li>
<li class="end">3</li>
```

И нам нужно уметь отдельно находить второй элемент (с текстом 2) и отдельно оба - первый (1) и третий (3). Мы можем увидеть, что их отличает значение атрибута `class`. У второго элемента это значение начинается с текста `"middle"`, а у первого и третьего - целое значение равно `"end"`.

Следовательно, мы можем построить и локаторы соответственно:
- найти элемент(ы), у которого значение атрибута класс начинается с текста `"middle"`

```poetry
[class**^=**'middle']
```

- найти элемент(ы), у которого целое значение атрибута класс равно тексту `"end"`

```poetry
[class**=**'end']
```

Аналогичные примеры будут и для XPATH селекторов. Иногда такой подход - единственное, что остается. Но в случае, когда мы работаем с атрибутом `class`, стоит быть осторожным.  Дело в том, что новые CSS классы склонны появляться у элементов время от времени. И если, как в примере выше, мы намертво привяжемся к полному значению атрибута `class`, либо, его началу, то если вдруг программисты решат повесить на наши элементы еще один css-класс, например `"start"`:

```html
<li class="start end">1</li>
<li class="start middle end">2</li>
<li class="start end">3</li>
```

то наши локаторы "сломаются" и перестанут находить нужные нам элементы. При этом фича, которую мы должны были покрывать в нашем тесте, где мы использовали эти локаторы, все еще должна работать, и, соответственно, результат теста будет не показательным с точки зрения его "цели тестирования". Такая [хрупкость локаторов может быть нежелательна](00-03-01-Q-selene-and-css.md#strict-or-stable-locators) на проектах, где могут иметь место частые изменения такого вида. В таких случаях стоит поискать более "гибкий" и "стабильный" локатор.

Обычно можно построить локатор через поиск по вхождению определенного текста в значение атрибута, или даже по вхождению "слова" в значение атрибута. В CSS селекторах конкретно в случае поиске по CSS классу для этого даже есть специальное сокращение. Когда же нужно исключить из поиска элементы со значением атрибутов, имеющим определенные слова - для этого и в CSS и XPATH селекторах есть соответствующие модификаторы поиска.

*Решение...*

===

- найти второй элемент

```poetry
[class**~=**'middle']
```
или лучше:

```poetry
**.**middle
```
- найти все элементы кроме второго

```poetry
**:not(.**middle**)**
```

===

#### Хрупкие гибкие локаторы. Привязка к частичному значению атрибута class {#fragile-flexible-locators-binding-to-partial-class-attribute}

Иногда с "гибкостью" локаторов можно перестараться, и в результате получится не [стабильный а хрупкий локатор](00-03-01-Q-selene-and-css.md#strict-or-stable-locators).

Допустим, у нас есть html-код:

```html
<li class="foo bar">1</li>
<li class="foo">2</li>
<li class="foo bar">3</li>
```

Нам нужно уметь находить элементы с классом `bar`. И вот мы строим наш локатор по принципу:

- найти элемент(ы), у которых значение атрибута `class` содержит (contains) текст `"bar"`.

```poetry
[class*="bar"]
```

И тут девелоперы в какой-то момент осознали, что есть особенный вид элементов `foobar` (привет утконосам из Австралии;)).

```html
<li class="foo bar">1</li>
<li class="foo">2</li>
<li class="foo bar">3</li>
<li class="foobar">4</li>
```

И вуаля, локатор, который был предназначен для нахождения только элементов `"bar"`, теперь находит и элементы `"foobar"`.

Поэтому когда мы работаем с определением элементов исходя из значений атрибута class - обычно лучше искать "по CSS class-у", то есть вхождению соответствующего "**целого** слова" в значение атрибута (учти, что *СSS class* - это одно из слов в значении атрибута `class`, а *class* - это имя одноименного атрибута)

*Решение...*

===

```poetry
.bar
```

===

#### Построение локатора с помощью менее читабельных и понятных атрибутов либо их значений {#building-locators-with-notreadable-attributes-or-their-values}

*Пример*

```poetry
browser.all('#todo-list li**[class="ember_view"]**')\
    .should(have.exact_texts('a', 'c'))
```

Главная проблема в этом коде - это [потенциальная хрупкость локатора](00-03-01-Q-selene-and-css.md#strict-or-stable-locators), как следствие [привязки к целому значению атрибута class](#fragile-strict-locators-binding-to-full-class-attribute-or-its-parts).

Но есть и другая ошибка. Для построения локатора было выбрано значение `"ember-view"`, которое абсолютно ничего не говорит о том, о чем этот локатор. Этот локатор должен искать "активные задачи". А ищет какие-то "задачи с ember-view `о_О`". Более того, наше приложение построено на основе фронтенд-фреймворка "EmberJs" (вспомни каким был URL, по которому мы открывали приложение). Зная это можно догадаться, что этот css-класс `ember-view` еще и автосгенерирован скорее всего... А все, что генерируется автоматически и, по сути, является "динамически изменяемым" – явно не то, что будет "стабильным", а значит не то, на что стоит полагаться при построении стабильного "не хрупкого" локатора.  Иногда выбора нет, и более понятный локатор не построишь. Тогда, чтобы [код все еще был понятным, и его было просто поддерживать в будущем](https://en.wikipedia.org/wiki/Self-documenting_code), [используют переменные с более четким именем](00-03-01-Q-selene-and-css.md#when-to-move-locators-to-vars). Но в этом случае можно подобрать намного более читабельный и даже более лаконичный локатор. Также не забываем, что в этом задании мы не используем конструкции типа переменных или функций;)

*Подсказка 1...*
===

Сфокусируйся на том, что "должен найти локатор". А найти он должен "активные задачи". Каким другим способом можно перефразировать "активность" задачи?

*Подсказка 2...*
===

В этом случае можно построить более простой локатор исходя из того, что "активные задачи" - это тоже самое, что **"незавершенные задачи"**.

*Решение...*
===

```poetry
browser.all('#todo-list li**:not(.completed)**')\
    .should(have.exact_texts('a', 'c'))
```

===

#### Слишком краткие и потому менее информативные, неочевидные локаторы {#over-concised-locators}

Часто, с целью сделать локатор покороче, мы не учитываем того, что краткость может навредить читабельности и сделать тесты более сложными в восприятии (мы еще вернемся к этой теме в следующих уроках - [смотри раздел о читабельности и лаконичности...](./01-01-L-poc.md#tests-fast-in-impl-readability-and-conciseness))

Если тест откроет человек, который его не писал, и увидит там код с локатором вида:

*Пример 1*

```poetry
browser.element('**li**:nth-child(2) .toggle').click()
```

... ему может быть не очевидно, что `li` – это элемент списка задач, а не какого-то другого списка.

В следующем коде также "идет речь об элементах списка задач", но при этом локатор никак об этом не "информирует":

*Пример 2*

```poetry
browser.all(**'**.completed').should(have.exact_texts('b'))
```

*Решение...*

===

*Пример 1*

```poetry
browser.element('**#todo-list **li:nth-child(2) .toggle').click()
```

*Пример 2*

```poetry
browser.all('**#todo-list li**.completed').should(have.exact_texts('b'))
```

===

#### Неконсистентные селекторы {#notconsistent-selectors}

*Пример*

```poetry
# ...
browser.all('**#todo-list li**').should(have.exact_texts('a', 'b', 'c'))

browser.element('**#todo-list>li**:nth-of-type(2) .toggle').click()
# ...
```

Важно быть как можно более последовательным и единообразным в построении локаторов. Потому что чем больше мы сделаем код "разнообразным" – тем сложнее его будет понимать другим, тем менее читабельными будут тесты, тем больше у других членов команды будет уходить времени на поддержку тестов. А в тестах очень важна читабельность, учитывая то, что их очень много, их пишут разные люди и когда тесты падают – нужно как можно быстрее понять что произошло, найти и разобраться с причиной.

В коде выше для нахождения одних и тех же сущностей – элементов задач – используются разные селекторы:
- `#todo-list li` (ищет все элементы `li` внутри элемента `#todo-list` на любой глубине вложенности)
- `#todo-list>li` (ищет все элементы `li` внутри элемента `#todo-list` на первом уровне вложенности)

Это будет сбивать с толку во время разбора кода теста тех, кто его не писал. Ведь первый сигнал, который поступит в мозг от глаз, будет – "это разные селекторы". И только потом, затратив время на обработку, мозг поймет, что это один и тот же селектор. Зачем же утруждать его лишней работой? ;)

Еще один минус в том, что при глобальной замене этой части селектора на какую-то другую, не получится заменить все вхождения сразу, как раз за счет того, что эти части селектора – неконсистентны. Конечно, можно сказать, что если бы мы вынесли эту часть в переменную, то и проблемы такой бы не было. Но контексты могут быть разными на разных проектах, и [не всегда может быть полезно использовать переменные](00-03-01-Q-selene-and-css.md#when-to-move-locators-to-vars).

*Решение...*

либо:

```poetry
# ...
browser.all('**#todo-list>li**').should(have.exact_texts('a', 'b', 'c'))

browser.element('**#todo-list>li**:nth-of-type(2)').element('.toggle').click()
# ...
```
либо:

```poetry
# ...
browser.all('**#todo-list li**').should(have.exact_texts('a', 'b', 'c'))

browser.element('**#todo-list li**:nth-of-type(2)').element('.toggle').click()
# ...
```

Первый вариант более строгий, поэтому если на проекте велика вероятность, что появятся другие элементы `li` внутри `#todo-list` (например глубже...), то такой селектор будет менее "стабильным".

Второй вариант менее строгий, поэтому если вдруг текущие элементы `li` вследствие каких-то изменений "опустятся ниже" – он все еще будет работать. Такой селектор может быть более "стабильным" и "живучим".

Лучший вариант выбрать между двух невозможно, все зависит от проекта ;) Но можно начать с второго, а там видно будет ;)

*Другие примеры ошибок...*

```poetry

browser.all('#todo-list li').should(have.exact_texts('a', 'b', 'c'))
browser.element('li:nth-child(2) .toggle').click()
browser.element('.completed').should(have.exactText('b'))
browser.all('#todo-list [class|=ember-view]').should(have.exact_texts('a', 'c'))

```

Определившись с локатором для поиска "лист-айтема" (`li`) списка задач (`todo-list`):

```poetry

browser.all('**#todo-list li**').should(have.exact_texts('a', 'b', 'c'))

```

... уже в следующей строке кода для отображения того же самого элемента списка мы используем другой, пускай более короткий, но "неконсистентный" и менее информативный локатор:

```poetry

browser.element(**'li**:nth-child(2) .toggle').click()

```

... а теперь мы вообще забыли хоть как то упомянуть в локаторе о том что мы работаем с задачами:

```poetry

browser.element(**'**.completed').should(have.exactText('b'))

```

... и последней вишенькой на тортике, мы решили "для разнообразия" в этот раз опустить `li`

```poetry

browser.all('#todo-list** [**class|=ember-view]')\
    .should(have.exact_texts('a', 'c'))

```

А здесь кто-то решил побеспокоиться о других разработчиках, которые этот код не писали, чтобы как только они открыли код упавшего теста - глаза сразу увидели сквозь весь код, в каких строчках ведется работа с одними и теми же сущностями – `todo-list li`:

```poetry

browser.all('**#todo-list li**').should(have.exact_texts('a', 'b', 'c'))
browser.element('**#todo-list li**:nth-child(2) .toggle').click()
browser.element('**#todo-list li**.completed').should(have.exactText('b'))
browser.all('**#todo-list li***[class|=ember-view]*')\
    .should(have.exact_texts('a', 'c'))

```

При этом одна ошибка все еще осталась в последней строке (выделенная курсивом), [но о ней в другой раз;)](#building-locators-with-notreadable-attributes-or-their-values)

===

#### Фэншуй {#feng-shui}

Есть в программировании вещи, которые могут показаться неоправданными усилиями ради какого-то "сомнительного фэншуя". Например "отступы в коде", "дополнительные пустые строчки", подбор читабельных понятных имен, и т. д. Но, на самом деле, чем больше растет количество написанного кода в проекте, тем он более становится похожим на сложный организм человека, в котором при проведении операций хирургу непростительно быть "неаккуратным", да и операции проще проводить в теле с более-менее хорошим состоянием. Поэтому стоит задуматься о том, чтобы выработать у себя некоторые "задротские, но здоровые привычки" ;)

Хорошая новость в том, что большинство таких нюансов подсказывает IDE, PyCharm так точно хорошо с этим справляется (просто будь внимателен ко всему, что он подсвечивает), но и другие редакторы при соответствующих настройках хороши. Плюс сам питон с его зависимостью от отступов навязывает быть более аккуратным.

===

#### Фэншуй. Лишние пустые строки {#feng-shui-redundant-empty-lines}

```poetry
from selene import have
from selene.support.shared import browser


_ _
def test_completes_todo:
        _ _
        _ _
        browser.open('http://todomvc.com/examples/emberjs')

        _ _
        # ...code

        # ...code

```

Лишние пустые строки, на первый взгляд, достаточно безобидны, но если их использовать "с умом" – то с их помощью можно также выделять структуру в коде, например – блоки связанных шагов и проверок в коде тест-функции (~ "тест-кейса"). Да и основные части кода, такие как функции – также удобно отделять друг от друга пустыми строками, для "усиления" выразительности кода. И если где-то их использовать "с умом", а где-то "как попало", то от "усилий ума" толку не будет никакого;)

*Решение...*

===

```poetry
from selene import have
from selene.support.shared import browser


def test_completes_todo:
        browser.open('http://todomvc.com/examples/emberjs')

        # ...code

        # ...code

```

</ru>

<uk>


### Огляд завдання {#task-overview}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/9nOlSHFVENU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

**Ключ до розв'язку завжди криється в описі завдання, у вихідних умовах які нам відомі**

![image-20200424175636054](../resources/00-03-02-M-selene-and-css.assets/image-20200424175636054.png)



**Перші підказки прямим текстом згадуються в умові завдання:**

* фокусуватись на точній реалізації вказаних кроків сценарію:
  ![image-20200421155346253](../resources/00-03-02-M-selene-and-css.assets/image-20200421155346253.png)



* не використовувати певних методів Selene:
  ![image-20200426113651450](../resources/00-03-02-M-selene-and-css.assets/image-20200426113651450.png)

  Наприклад, наступна реалізація не вірна:

  ```python
  browser.all('.......').element_by(...).element('...').click()
  browser.all('.......').filtered_by(...).should(...)
  ```

  А шаблон наступної вже підходить:

  ```python
  browser.element('..................................').click()
  ...............('....................').should(...)
  ```




* це задача про CSS, тому ніяких XPath у розв'язку
  ![image-20200424175833737](../resources/00-03-02-M-selene-and-css.assets/image-20200424175833737.png)




* також ніяких абстракцій як то функцій чи змінних
  ![image-20200424175918302](../resources/00-03-02-M-selene-and-css.assets/image-20200424175918302.png)




* і найголовніша підказка – слідувати аналагічному до використаного в уроці підходу
  ![image-20200424180003751](../resources/00-03-02-M-selene-and-css.assets/image-20200424180003751.png)
  А значить, наприклад, не переходити на активний фільтр щоб перевірити те що задача завершена – в уроці для такої ж перевірки використовувався інший підхід;)
  ![image-20200424180127802](../resources/00-03-02-M-selene-and-css.assets/image-20200424180127802.png)



**Також не забувай про методику роботи з рев’ю:**

* при перегляді роби паузу і одразу вдосконалюй свій розв'язок кожного разу коли приходить розуміння що можна покращити
* у випадку питань – заглядай в [Список Частих Питань](./00-03-01-Q-selene-and-css.md)
* коли зустрічаєш якісь посилання – не поспішай переходити по ним, спробуй загуглити сам, і звіритись по фіналу, таким чином розвиваючи свої навички пошуку інформації
* за наявного відео, звертай увагу і на текст під ним – там може бути більше деталей, та й повторення, що мати вчення – домогти у знань структуруванні може ;)



================================================

### Структура git-проекту (poetry) {#git-project-structure-issues}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/ycmoxJmyaas" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

* має бути схожим на

  ```
  my-app-tests
  ├── .gitignore
  ├── .python-version
  ├── poetry.lock
  ├── pyproject.toml
  ├── README.rst
  ├── my_app_tests
  │   └── __init__.py
  └── tests
      ├── __init__.py
      └── test_my_app_tests.py
      └── test_*.py
  ```

  * зазвичай з іменем по шаблону
    * `<APP>-test`
    * чи `<APP>-tests`,
    * але в контексті «тренувального першого проекту»  ок і  просто `selene-intro`
  * з кореневим пакетом з таким самим іменем
    * [з](https://www.python.org/dev/peps/pep-0008/#package-and-module-names) `_` замість [усіх](https://www.w3schools.com/jsref/jsref_regexp_wordchar_non.asp) `\W`
  * з **.gitignore** всередині, що ігнорує все по типу `*.egg-info/`, `.pytest_cache`, і т.д.
    * [гугли](https://www.google.com/search?q=python+project+gitignore+example&oq=python+project+gitignore+example&aqs=chrome..69i57j33.12623j0j1&sourceid=chrome&ie=UTF-8) для [прикладів](https://github.com/github/gitignore/blob/master/Python.gitignore)
    * зверни увагу, що деякі файли може бути зручніше ігнорувати на рівні глобальної конфігурації git (шукай абзац `Patterns which a user wants Git to ignore in all situations` на [git-scm.com/docs/gitignore](https://git-scm.com/docs/gitignore)
  * якщо так сталось «що вже закомітив зайві файли»
    * [загугли](https://www.google.com/search?sxsrf=ALeKk003eKf8Rzg953gU9bGly646Ckqq_Q%3A1587741721991&ei=GQSjXuD4O8OxrgSDrIzQAg&q=git+remove+file+from+git+without+deleting+from+local&oq=git+remove+file+from+git+without+deleting+from+local&gs_lcp=CgZwc3ktYWIQAzIICCEQFhAdEB4yCAghEBYQHRAeMggIIRAWEB0QHjoECAAQRzoECCMQJzoGCAAQBxAeOgUIABDLAToCCAA6BggAEBYQHjoHCCEQChCgAToECAAQEzoICAAQFhAeEBM6BQghEKABUL1TWP-ZAWCrowFoBXADeAGAAY4LiAHDMpIBCjAuMzAuMy43LTGYAQCgAQGqAQdnd3Mtd2l6&sclient=psy-ab&ved=0ahUKEwig6dXqroHpAhXDmIsKHQMWAyoQ4dUDCAw&uact=5) як їх видалити «тільки з під гіта», [не видаляючи з локальної робочої директорії](https://stackoverflow.com/questions/1143796/remove-a-file-from-a-git-repository-without-deleting-it-from-the-local-filesyste)





=============================

### Іменування тестів {#test-naming}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/tOWXfeV1KnE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/EOiiYAuhWp8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

#### Структурна інформація в імені тест-кейсу {#structural-info-in-a-test-case-name}

![image-20200424183604622](../resources/00-03-02-M-selene-and-css.assets/image-20200424183604622.png)

![image-20200421153930475](../resources/00-03-02-M-selene-and-css.assets/image-20200421153930475.png)



#### Структурна інформація в імені тест-суіту {#structural-info-in-a-test-suite-name}

![image-20200424183531788](../resources/00-03-02-M-selene-and-css.assets/image-20200424183531788.png)

#### Порушення домовленостей по іменуванню {#against-naming-conventions}

![image-20200424183708748](../resources/00-03-02-M-selene-and-css.assets/image-20200424183708748.png)

[в той час як…](https://pytest.readthedocs.io/en/reorganize-docs/new-docs/user/naming_conventions.html)

![image-20200421163855698](../resources/00-03-02-M-selene-and-css.assets/image-20200421163855698.png)


#### Ім'я тест-кейсу не чітко відображає ціль тестування {#test-case-name-does-not-reflect-test-goal-precisely-enough}

```python
def test_todos():
  # ...
```

#### Ім'я тест-суіту не чітко відображає ціль тестування {#test-suite-name-does-not-reflect-test-goal-precisely-enough}

![image-20200421164240235](../resources/00-03-02-M-selene-and-css.assets/image-20200421164240235.png)



#### Поради {#naming-hints}

* для структуруючої організаційної інформації використовуй пакети Python (теки з файлами `__init__.py`)
* подумай над тим скільки рівнів вкладеності для тек, щоб все організувати у найбільш легкий для розуміння шлях
* постарайся зменшити тавтологію для більшої чіткості переданої інформації
* слідуй [домовленостям по складанню імен для тестів](https://pytest.readthedocs.io/en/reorganize-docs/new-docs/user/naming_conventions.html)
* враховуй контекст в якому підбирається ім’я, відображай ціль тестування в імені тест-суіту чи тест-кейсу



,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

#### ⇩Розв'язок⇩ {#naming-solution}

==================


![image-20200421163813393](../resources/00-03-02-M-selene-and-css.assets/image-20200421163813393.png)





====================================

### Структура і коментарі {#structure-and-comments}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/0IaRLlLEFTQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/4Dc_4cIQRiQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Структура коду має прямий ефект на його читабельність, швидке розуміння і відповідно на його подальшу підтримку. В контексті коду що реалізує певний тестовий сценарій, нам в першу чергу важливо зробити все можливе для того, щоб можна було чітко прослідкувати структуру [«тестової логіки»](./faq.md#test-logic), що включає в нашому контексті:

- передумову (precondition)
- кроки тесту (test steps)
- перевірки-асерти (assertions – порівняння актуальних результатів з очікуваними)



================================================

#### Коментарі що не додають цінності {#comments-that-add-non-value}

 ```python
def test_complete():
    # open TodoMVC page
    browser.open('http://todomvc.com/examples/emberjs/')
 ```



####  Коментарі що дублюють код, який може змінитись з часом (як то тестові дані) {#comments-duplicate-things-that-may-change}

```python
    # add todos: "a", "b", "c"
    browser.element('#new-todo').type('a').press_enter()
    browser.element('#new-todo').type('b').press_enter()
    browser.element('#new-todo').type('c').press_enter()
```



#### Занадто технічні коментарі {#not-business-value-oriented-comments}

 ```python
    # toggle b
    browser.element('...').click()
 ```

… насправді, тут користувач виконує операцію «завершення» (complete) задачі



#### Коментарі що роблять код занадто багатослівним перекриваючи його структуру {#too-wordy-comments}

*приклад для версії коду з уроку «Selene в дії», без обмежень використання методів Selene*

```python
def test_complete():
    # open todomvc
    browser.open('http://todomvc.com/examples/emberjs/')
    # add 'a'
    browser.element('#new-todo').type('a').press_enter()
    # add 'b'
    browser.element('#new-todo').type('b').press_enter()
    # add 'c'
    browser.element('#new-todo').type('c').press_enter()
    # todos should be 'a', 'b', 'c'
    browser.all('#todo-list>li').should(have.exact_texts('a', 'b', 'c'))
    # complete 'b'
    browser.all('#todo-list>li').element_by(have.exact_text('b'))\
        .element('.toggle').click()
    # complete todos should be: 'b'
    browser.all('#todo-list>li').filtered_by(have.css_class('completed'))\
        .should(have.exact_texts('b'))
    # active todos should be: 'a', 'c'
    browser.all('#todo-list>li').filtered_by(have.no.css_class('completed'))\
        .should(have.exact_texts('a', 'c'))
```



#### Нечітка тест-логіка через зависоку «щільність» коду (без розділення блоків, наприклад пустими рядками)  {#high-density-code}

*приклад для версії коду з уроку «Selene в дії», без обмежень використання методів Selene*

```python
def test_complete():
    browser.open('http://todomvc.com/examples/emberjs/')
    browser.element('#new-todo').type('a').press_enter()
    browser.element('#new-todo').type('b').press_enter()
    browser.element('#new-todo').type('c').press_enter()
    browser.all('#todo-list>li').should(have.exact_texts('a', 'b', 'c'))
    browser.all('#todo-list>li').element_by(have.exact_text('b'))\
        .element('.toggle').click()
    browser.all('#todo-list>li').filtered_by(have.css_class('completed'))\
        .should(have.exact_texts('b'))
    browser.all('#todo-list>li').filtered_by(have.no.css_class('completed'))\
        .should(have.exact_texts('a', 'c'))
```

… у такому коді важко з першого погляду зрозуміти основну [тестову логіку](./faq.md#test-logic), і відповісти на питання типу «скільки кроків в контексті бізнес-сценарію робить користувач» (має бути 3)



####  Нечітка тест-логіка через зависоку «розрідженість» коду (забагато пустих рядків) {#rarefied-code}

*приклад для версії коду з уроку «Selene в дії», без обмежень використання методів Selene*

```python
def test_complete():
    browser.open('http://todomvc.com/examples/emberjs/')

    browser.element('#new-todo').type('a').press_enter()

    browser.element('#new-todo').type('b').press_enter()

    browser.element('#new-todo').type('c').press_enter()

    browser.all('#todo-list>li').should(have.exact_texts('a', 'b', 'c'))

    browser.all('#todo-list>li').element_by(have.exact_text('b'))\
        .element('.toggle').click()

    browser.all('#todo-list>li').filtered_by(have.css_class('completed'))\
        .should(have.exact_texts('b'))

    browser.all('#todo-list>li').filtered_by(have.no.css_class('completed'))\
        .should(have.exact_texts('a', 'c'))
```



#### Неконсистентність в структурі {#not-consistent-structure}

*приклад для версії коду з уроку «Selene в дії», без обмежень використання методів Selene*

```python
def test_complete():
    browser.open('http://todomvc.com/examples/emberjs/')

    browser.element('#new-todo').type('a').press_enter()
    browser.element('#new-todo').type('b').press_enter()
    browser.element('#new-todo').type('c').press_enter()

    browser.all('#todo-list>li').should(have.exact_texts('a', 'b', 'c'))

    browser.all('#todo-list>li').element_by(have.exact_text('b'))\
        .element('.toggle').click()
    browser.all('#todo-list>li').filtered_by(have.css_class('completed'))\
        .should(have.exact_texts('b'))
    browser.all('#todo-list>li').filtered_by(have.no.css_class('completed'))\
        .should(have.exact_texts('a', 'c'))
```



#### Поради {#structure-hints}


* уникай коментарів, слідуй підходу самодокументованого коду – [Self-Documenting Code](https://en.wikipedia.org/wiki/Self-documenting_code)

  * замість коментарів, обирай більш читабельний спосіб в реалізації коду або створи змінну чи функцію з відповідним читабельним іменем, що приховає складність коду, що не вдалось спростити

    * тільки не в цьому завданні;)
* якщо таки бачиш сенс у додатковому коментуванні – формуй коментарі більше як «заголовки» для більш ясного покриття і структурування, але не як «документування коду що може змінитись»

  * розглянь варіант використання стилю [Gherkin](https://en.wikipedia.org/wiki/Behavior-driven_development#Behavioral_specifications) з [BDD](https://en.wikipedia.org/wiki/Behavior-driven_development) (GIVEN/WHEN/THEN)
    для підкреслення структури [тестової логіки](./faq.md#test-logic) (передумова/кроки/перевірка очікуваного результату/...)
* використовуй пусті рядки для виділення основних структурних блоків відповідно до [тест-логіки](./faq.md#test-logic)

  * зазвичай, є сенс згрупувати тестовий крок і його перевірку в межах одного блоку
* якщо вже використовуєш коментарі – вони самі по собі можуть слугувати розділювачами на блоки

  * але пусті рядки можуть ще більше покращити проглядання структури тесту
  * також в такому разі пусті рядки тепер можуть і виділяти перевірки в межах блоку



,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

#### ⇩Розв’язок⇩ {#structure-solution}

==================



*приклад для версії коду тесту з уроку «Selene в дії» при його розгляді в контексті двох різних стилів реалізації тестів – «багато фіч в одному тесті» (так звані End-to-End чи E2E тести) і «одна фіча на тест» (так звані Атомарні тести)*



##### E2E тільки з пустими рядками для розділення на блоки {#e2e-with-only-empty-lines}

```python
def test_todo_management():
    browser.open('http://todomvc.com/examples/emberjs/')

    browser.element('#new-todo').type('a').press_enter()
    browser.element('#new-todo').type('b').press_enter()
    browser.element('#new-todo').type('c').press_enter()
    browser.all('#todo-list>li').should(have.exact_texts('a', 'b', 'c'))

    browser.all('#todo-list>li').element_by(have.exact_text('b'))\
        .element('.toggle').click()
    browser.all('#todo-list>li').filtered_by(have.css_class('completed'))\
        .should(have.exact_texts('b'))
    browser.all('#todo-list>li').filtered_by(have.no.css_class('completed'))\
        .should(have.exact_texts('a', 'c'))

    ...
```



##### E2E з коментарями як заголовками про покриття плюс для розділення на блоки {#e2e-with-comments-as-coverage-titles-n-block-separators}

```python
def test_todo_management():
    browser.open('http://todomvc.com/examples/emberjs/')
    # Add
    browser.element('#new-todo').type('a').press_enter()
    browser.element('#new-todo').type('b').press_enter()
    browser.element('#new-todo').type('c').press_enter()
    browser.all('#todo-list>li').should(have.exact_texts('a', 'b', 'c'))
    # Complete
    browser.all('#todo-list>li').element_by(have.exact_text('b'))\
        .element('.toggle').click()
    browser.all('#todo-list>li').filtered_by(have.css_class('completed'))\
        .should(have.exact_texts('b'))
    browser.all('#todo-list>li').filtered_by(have.no.css_class('completed'))\
        .should(have.exact_texts('a', 'c'))
    # ...
```



##### E2E з коментарями як заголовками про покриття плюс пустими рядками для розділення на блоки {#e2e-with-comments-as-coverage-titles-n-empty-lines}

```python
def test_todo_management():
    browser.open('http://todomvc.com/examples/emberjs/')

    # Add
    browser.element('#new-todo').type('a').press_enter()
    browser.element('#new-todo').type('b').press_enter()
    browser.element('#new-todo').type('c').press_enter()
    browser.all('#todo-list>li').should(have.exact_texts('a', 'b', 'c'))

    # Complete
    browser.all('#todo-list>li').element_by(have.exact_text('b'))\
        .element('.toggle').click()
    browser.all('#todo-list>li').filtered_by(have.css_class('completed'))\
        .should(have.exact_texts('b'))
    browser.all('#todo-list>li').filtered_by(have.no.css_class('completed'))\
        .should(have.exact_texts('a', 'c'))

    # ...
```



##### E2E з коментарями в стилі BDD як заголовками про покриття плюс пустими рядками для розділення на блоки {#e2e-with-bdd-style-comments-as-coverage-titles-n-empty-lines}

```python
def test_todo_management():
  	# GIVEN
    browser.open('http://todomvc.com/examples/emberjs/')

    # THEN add
    browser.element('#new-todo').type('a').press_enter()
    browser.element('#new-todo').type('b').press_enter()
    browser.element('#new-todo').type('c').press_enter()
    browser.all('#todo-list>li').should(have.exact_texts('a', 'b', 'c'))

    # THEN Complete
    browser.all('#todo-list>li').element_by(have.exact_text('b'))\
        .element('.toggle').click()
    browser.all('#todo-list>li').filtered_by(have.css_class('completed'))\
        .should(have.exact_texts('b'))
    browser.all('#todo-list>li').filtered_by(have.no.css_class('completed'))\
        .should(have.exact_texts('a', 'c'))

    # ...
```



##### E2E з коментарями як заголовками про покриття, пустими рядками для розділення на блоки і виділення перевірок всередині {#e2e-with-comments-as-coverage-titles-n-empty-lines-2-separate-blocks-and-asserts}

```python
def test_todo_management():
    browser.open('http://todomvc.com/examples/emberjs/')

    # Add
    browser.element('#new-todo').type('a').press_enter()
    browser.element('#new-todo').type('b').press_enter()
    browser.element('#new-todo').type('c').press_enter()

    browser.all('#todo-list>li').should(have.exact_texts('a', 'b', 'c'))

    # Complete
    browser.all('#todo-list>li').element_by(have.exact_text('b'))\
        .element('.toggle').click()

    browser.all('#todo-list>li').filtered_by(have.css_class('completed'))\
        .should(have.exact_texts('b'))
    browser.all('#todo-list>li').filtered_by(have.no.css_class('completed'))\
        .should(have.exact_texts('a', 'c'))

    # ...
```



##### Атомарні тести без коментарів {#atomic-without-comments}

```python
def test_complete():
    browser.open('http://todomvc.com/examples/emberjs/')
    browser.element('#new-todo').type('a').press_enter()
    browser.element('#new-todo').type('b').press_enter()
    browser.element('#new-todo').type('c').press_enter()
    browser.all('#todo-list>li').should(have.exact_texts('a', 'b', 'c'))

    browser.all('#todo-list>li').element_by(have.exact_text('b'))\
        .element('.toggle').click()

    browser.all('#todo-list>li').filtered_by(have.css_class('completed'))\
        .should(have.exact_texts('b'))
    browser.all('#todo-list>li').filtered_by(have.no.css_class('completed'))\
        .should(have.exact_texts('a', 'c'))
```



##### Атомарні з коментарями, що структурують код в стилі BDD {#atomic-with-structural-bdd-comments}

```python
def test_complete():
  	# GIVEN
    browser.open('http://todomvc.com/examples/emberjs/')
    browser.element('#new-todo').type('a').press_enter()
    browser.element('#new-todo').type('b').press_enter()
    browser.element('#new-todo').type('c').press_enter()
    browser.all('#todo-list>li').should(have.exact_texts('a', 'b', 'c'))
    # WHEN
    browser.all('#todo-list>li').element_by(have.exact_text('b'))\
        .element('.toggle').click()
    # THEN
    browser.all('#todo-list>li').filtered_by(have.css_class('completed'))\
        .should(have.exact_texts('b'))
    browser.all('#todo-list>li').filtered_by(have.no.css_class('completed'))\
        .should(have.exact_texts('a', 'c'))
```



##### Атомарні з коментарями, що структурують код в стилі BDD плюс пусті рядки для додаткового виділення блоків {#atomic-with-structural-bdd-comments-and-empty-lines}

```python
def test_complete():
  	# GIVEN
    browser.open('http://todomvc.com/examples/emberjs/')
    browser.element('#new-todo').type('a').press_enter()
    browser.element('#new-todo').type('b').press_enter()
    browser.element('#new-todo').type('c').press_enter()
    browser.all('#todo-list>li').should(have.exact_texts('a', 'b', 'c'))

    # WHEN
    browser.all('#todo-list>li').element_by(have.exact_text('b'))\
        .element('.toggle').click()

    # THEN
    browser.all('#todo-list>li').filtered_by(have.css_class('completed'))\
        .should(have.exact_texts('b'))
    browser.all('#todo-list>li').filtered_by(have.no.css_class('completed'))\
        .should(have.exact_texts('a', 'c'))
```



##### Атомарні з коментарями про покритий функціонал, що структурують код в стилі BDD плюс пусті рядки для додаткового виділення блоків {#atomic-with-coverage-n-structural-bdd-comments-n-empty-lines}

```python
def test_complete():
  	# GIVEN todos added
    browser.open('http://todomvc.com/examples/emberjs/')
    browser.element('#new-todo').type('a').press_enter()
    browser.element('#new-todo').type('b').press_enter()
    browser.element('#new-todo').type('c').press_enter()
    browser.all('#todo-list>li').should(have.exact_texts('a', 'b', 'c'))

    # WHEN complete
    browser.all('#todo-list>li').element_by(have.exact_text('b'))\
        .element('.toggle').click()

    # THEN
    browser.all('#todo-list>li').filtered_by(have.css_class('completed'))\
        .should(have.exact_texts('b'))
    browser.all('#todo-list>li').filtered_by(have.no.css_class('completed'))\
        .should(have.exact_texts('a', 'c'))
```



##### Атомарні з коментарями про покритий функціонал, що структурують код в стилі BDD, з пустим рядками для додаткового виділення блоків та опущеною перевіркою в блоці передумови тесту {#atomic-with-coverage-n-structural-bdd-comments-n-empty-lines-n-no-assert-in-given}

```python
def test_complete():
  	# GIVEN todos added
    browser.open('http://todomvc.com/examples/emberjs/')
    browser.element('#new-todo').type('a').press_enter()
    browser.element('#new-todo').type('b').press_enter()
    browser.element('#new-todo').type('c').press_enter()

    # WHEN complete
    browser.all('#todo-list>li').element_by(have.exact_text('b'))\
        .element('.toggle').click()

    # THEN
    browser.all('#todo-list>li').filtered_by(have.css_class('completed'))\
        .should(have.exact_texts('b'))
    browser.all('#todo-list>li').filtered_by(have.no.css_class('completed'))\
        .should(have.exact_texts('a', 'c'))
```





====================================================

### Iнші проблеми з читабельністю {#other-readability-issues}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/3DpjdzgZ5-U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

«Бути читабельним» є одним з найпростіших, прородніх і найбільш універсальних принципів для слідування ;)



====================================

#### `s` проти `browser.element` {#s-vs-browser-element}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/D6baFGhKjL8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

```python
browser.open('http://todomvc.com/examples/emberjs/')

s('#new-todo').type('a').press_enter()
s('#new-todo').type('b').press_enter()
s('#new-todo').type('c').press_enter()
ss('#todo-list>li').should(have.exact_texts('a', 'b', 'c'))
```

… виграючи в стислості, такий код може бути для декого недостатньо очевидним і читабельним

```python
browser.open('http://todomvc.com/examples/emberjs/')

browser.element('#new-todo').type('a').press_enter()
browser.element('#new-todo').type('b').press_enter()
browser.element('#new-todo').type('c').press_enter()
browser.all('#todo-list>li').should(have.exact_texts('a', 'b', 'c'))
```

… програючи в стислості, такий більш багатослівний код є абсолютно зрозумілим і очевидним



**ПОРАДИ**

* можеш обрати будь-який спосіб, але роби це свідомо ;)
  * обираючи стисліші `s` та `ss` запевнись що кожен в команді розуміє і згоден з таким вибором «шорткатів»



======================

#### Подвійні лапки {#double-quotes}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/etb2c3pAtsw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

… захаращують код, роблять його менш «ясним»

```python
browser.open("http://todomvc.com/examples/emberjs/")

browser.element("#new-todo").type("a").press_enter()
browser.element("#new-todo").type("b").press_enter()
browser.element("#new-todo").type("c").press_enter()
browser.all("#todo-list>li").should(have.exact_texts("a", "b", "c"))
```

… а також їх довше і важче набирати – треба натискати додатково Shift



,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ'ЯЗОК⇩**

=============



```python
browser.open('http://todomvc.com/examples/emberjs/')

browser.element('#new-todo').type('a').press_enter()
browser.element('#new-todo').type('b').press_enter()
browser.element('#new-todo').type('c').press_enter()
browser.all('#todo-list>li').should(have.exact_texts('a', 'b', 'c'))
```





==================================================================================

#### Використання  занадто загальних і тому не точних тегів чи стандартних атрибутів типу type {#too-general-not-value-oriented-anchor-in-selector}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/NAdOSjHiAwM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>



```python
...........('..................input').click()
```

```python
...........('..................[type=checkbox]').click()
```

… не показує точно про який саме з функціональної точки зору елемент `input` або `checkbox` іде мова.



**ПОРАДИ**

* надавай перевагу цілеорієнтованим атрибутам замість тегів  чи «загальних атрибутів» як то `type`  при побудові селектора елемента для більшої його чіткості і ясності
  * зазвичай такого роду атрибути призначаються розробниками свідомо
    *  інакше попроси їх це зробити
       *  унікальні елементи на сторінці повинні мати унікальний атрибут `id`
       *  елементи що належать певній категорії чи то пак класу елементів – повинні мати відповідний CSS-клас в значенні атрибуту `class`
    *  ще краще навчитись додавати такі атрибути самотужки



,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ'ЯЗОК⇩**

=============



```python
...........('................ .toggle').click()
```





===================================================================================

#### Не цілезорієнтовані атрибути в селекторах {#not-a-value-oriented-attribute-in-selector}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/EmwVFtS26l4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

```python
...........('#todo-list .ember-view......').click()
```



**ПОРАДИ**

* постарайся знайти атрибут або в крайньому разі тег, що відбиває цінність елементу з точки зору користувача, передає ціль використання елементу
  * по можливості попроси розробників додати відповідний атрибут
    * а ще краще – будь здатним додати його сам;)



,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ'ЯЗОК⇩**

=============



```python
...........('#todo-list li..............').click()
```

чи

```python
...........('#todo-list>li..............').click()
```





============================================================

#### Занадто багатослівні і громіздкі селектори {#wordy-selectors}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/k0RBbGnh83c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

```python
browser.element('input#new-todo').type(...)
```



**ПОРАДИ**

* надавай перевагу більш стислим, і все ще достатньо читабельним селекторам



,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ'ЯЗОК⇩**

=============



```python
browser.element('#new-todo').type(...)
```





==============================================================================

#### Заплутане використання типу атрибуту в селекторі {#confusing-usage-of-attribute-type}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/eKbIVMbNo-c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

```python
browser.element('.todo-list ...........').click()
```

… крапка `.` на початку селектора говорить, що ми шукаємо елемент, який є «одним з багатьох» (саме таке значення мають зазвичай CSS-класи що призначаються елементам, і по яким потім можна знайти елемент через синтаксис `.css-class`). В нашому ж випадку даний елемент є унікальним батьківським елементом для усіх елементів задач (`todos`)



**ПОРАДИ**

* щоб обрати кращу характеристику елементу, до якої прив’язатись в селекторі для пошуку елемента
  * шукай наявний CSS-клас, якщо елемент є «одним серед багатьох належних певній групі»
  * шукай наявний атрибут `id` якщо елемент є унікальним елементом на сторінці



,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ'ЯЗОК⇩**

=============



```python
browser.element('#todo-list ...........').click()
```





========================================================================

####  Заплутане використання пробілів в CSS-селекторах {#confusing-usage-of-spaces-in-css-selectors}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/1zcTid8-XZU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

```python
browser.element('#todo-list > li.......').click()
```

… є валідним локатором, але, оскільки, пробіли мають спеціальне значення у CSS – їх присутність довкола `>` може ускладнити розуміння головної цілі селектору з «першого погляду»



**ПОРАДИ**

* будь точним – використовуй або `>` або ` `



,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ'ЯЗОК⇩**

=============



```python
browser.element('#todo-list>li.......').click()
```





====================================

#### Неконсистентні локатори {#inconsistent-locators}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/rn4YnM4qc2Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

```python
...
browser.all('#todo-list>li').should(have.exact_texts('a', 'b', 'c')
...
...........('#todo-list li...')...

```



```python
...
browser.all('#todo-list>li').should(have.exact_texts('a', 'b', 'c')
...
...........('#todo-list>.some-css-class...')...
```



**ПОРАДИ**

* будь консистентним заради простоти, ясності і відповідно кращої читабельності
  *  а також для послідуючого легшого рефакторингу



,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ'ЯЗОК⇩**

=============



```python
...
browser.all('#todo-list li').should(have.exact_texts('a', 'b', 'c')
...
...........('#todo-list li...')...

```

чи

```python
...
browser.all('#todo-list>li').should(have.exact_texts('a', 'b', 'c')
...
...........('#todo-list>li...')...
```



================================================

#### Не ясні занадто короткі селектори {#unclear-too-short-selectors}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/U9rmcph8dck" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

```python
'.ember-view ...'
```

```python
'.completed'
```

… не чітко показують які саме елементи локалізуються, роблячи код не повністю зрозумілим і тому не читабельним. На додачу, вони можуть бути [крихкими](#stable-vs-fragile-locators) і часто «ламатись», приводити код до падіння. Також можуть бути [неконсистентними](#inconsistent-locators)



**ПОРАДИ**

* обирай читальні атрибути що відбивають ціль і призначення відповідних елементів
  * якщо ти уже знаходиш певні елементи в коді певним чином, і далі в іншому місці тобі потрібно їх відфільтрувати по певній характеристиці, як то CSS-класі, то починай свій селектор з «базового селектора» оригінальних елементів, наприклад:
    * `'.element.special'`
    * `'#parent>child.special'`
* прямуй до стислості, але не погіршуючи читабельність



,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ'ЯЗОК⇩**

=============



```python
'#todo-list>li'
```

```python
'#todo-list>li.completed'
```





========================================================

### Стабільні локатори проти крихких {#stable-vs-fragile-locators}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/rwwFGlHXBcc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Зазвичай існує декілька способів написати локатор щоб знайти один і той же елемент на сторінці. Можна використовувати дуже багато інформації про структуру html (вкладеність елементів, порядок їх слідування один за одним, їх теги) та змісту (тексти, значення атрибутів елементів) і тоді вийде «жорсткий» локатор. Або використовувати мінімум інформації – і тоді вийде «слабкий» або «гнучкий» локатор. В наступній серії помилок ми розглянемо типові випадки, коли через занадто велику жорсткість чи гнучкість [локатори приводять до нестабільних «крихких» тестів](./00-03-01-Q-selene-and-css.md#strict-or-stable-locators).



=================================================================

#### Динамічно згенеровані атрибути в селекторах {#dynamic-attributes-in-selectors}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/6dJK4BFgWcA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

```python
browser.element('#todo-list #ember11...').click()
```

чи

```python
browser.element('#todo-list .ember-view...').click()
```

… є крихкими, тому що відповідні значення атрибутів можуть бути динамічно пере генерованими фреймворком що використовується на фронтенді



**ПОРАДИ**

* коли всі атрибути є динамічними
  * розглянь пошук елементу по тегу всередині батьківського елемента (бажано прямого «батька», а не «діда» чи «прадіда»), у якого є  відповідний унікальний атрибут, як то у нашому випадку з елементами задач – `#todo-list`
    * а потім, якщо потрібно, звузь пошук до потрібного елементу якщо він один з багатьох у списку – через, наприклад, вказування його номеру
      * дивись також [nth-child проти nth-of-type](#nth-child-vs-nth-of-type)



=======================================================

#### Крихкі селектори з прив’язкою до тегів {#fragile-selectors-with-tag-anchors}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/Dr0Gk-0DiJo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

```python
...........('........................input').click()
```

… може зламатись якщо розробники поміняють реалізацію елементу з тегу `input` на `button`, і т.д.



**ПОРАДИ**

* теги схильні до змін
  * тому надавай перевагу атрибутам з читабельними значеннями, що відбивають цінність чи то пак «ціль» елемента
    * адже, зазвичай, саме для останнього атрибути й призначають розробники елементам – щоб відобразити їх певний функціональний аспект
      *  якщо так сталось, що атрибутів немає, попроси розробників їх додати
         *  зазвичай унікальні елементи на сторінці повинні мати унікальний атрибут `id`
         *  а елементи що належать певному типу чи то пак класу елементів – повинні мати відповідний цілеорієнтований CSS-клас
    *  а ще краще – будь здатен сам додати такого роду атрибути

* якщо атрибуту дочекатись не вийшло, то тоді при використанні тегу варто «уточнити» пошук в середині батьківського елемента (бажано прямого «батька», а не «діда» чи «прадіда»), у якого є  відповідний унікальний атрибут, як то у нашому випадку з елементами задач:

  ```python
  browser.element('#todo-list>li.......').click()
  ```



,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ'ЯЗОК⇩**

=============



```python
...........('..................... .toggle').click()
```



====================================================================

#### Крихкі селектори з прив’язкою до точного шляху {#fragile-selectors-with-binding-to-exact-path}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/LKoSK99raL8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

```python
...........('................>div>.destroy').click()
```

… може зламатись, якщо, наприклад, розробники додадуть ще один `div` поміж `div>input`.



**ПОРАДИ**

* якщо у потрібного елемента є відповідна точна характеристика, як то CSS-клас до якої можна прив’язатись при пошуку
  * не прив’язуйся до точного шляху, що відображений у селекторі через прямий пошук «дитини» у «батька» через `>`
* [розглянь]({#parent-child-vs-parent-descendant}) використання пробілів в селекторі для пошуку усіх «нащадків» замість «прямих дітей»



,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ'ЯЗОК⇩**

=============



```python
...........('................ .destroy').click()
```





=========================================================

#### `parent>child` проти `parent descendant` {#parent-child-vs-parent-descendant}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/teBQnbTHH-o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

```python
browser.element('#todo-list>li............').click()
```

… зламається, якщо елемент `li` стане онукою для  `#todo-list` замість того щоб бути «прямою дитиною», наприклад якщо `id=todo-list` перенесуть з елемента `ul` на вже його батька – `div`...

```python
browser.element('#todo-list li............').click()
```

… може зламатись, якщо з-поміж нащадків батька-засновника `#todo-list` з’являться елементи `li`, які будуть представляти не задачі, а щось інше...



**ПОРАДИ**

* спробуй свідомо відчути і передбачити в контексті свого проекту, який тип змін в DOM має вищу ймовірність
  * якщо не виходить – просто вибери найпростіший спосіб
    * в більшості випадків, коли у нас є можливість прив’язатись до атрибутів, а не до більш крихких тегів – стабільнішим буде селектор з пошуком «по нащадку», як то `#parent .descendant` чи `.parent .descendant`
    * коли ж ми мусимо прив’язатись до тегу елемента, то в більшості випадків краще «зафіксувати шлях до нього» від його «прямого батька», особливо якщо «дитинно-батьківські» відносити задані якимось стандартним «шаблоном»  в HTML, як то є з елементами `ul>li`
      * відповідно наш приклад вище з `ul>li`, можливо, є трохи надуманим, адже така схема формування списку є стандартною в HTML, а тому у випадку тегів `ul` та `li` можна спокійніше формувати селектор як пошук «прямої дитини» через `>`
      * але всяке може бути, і в будь-якому випадку запам’ятай цей нюанс і на випадки з іншими тегами
      * та будь свідомим у своєму виборі ;)



====================================

#### nth-child проти nth-of-type {#nth-child-vs-nth-of-type}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/HvxJ4wcVATA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

```python
browser.element('#todo-list>li:nth-child(2)...').click()
```

… впаде якщо у `li` з’являться нові «сестри» чи «брати» іншого типу


ПРИКЛАД

```html
<ul id="todo-list">
  <li>...a...</li>
  <div>...</div>
  <li>...b...</li>
  ...
</ul>
```

… тепер, після появи нового брата `div` – `li` з `b` вже не є 2-гою дитиною в сім’ї батька `#todo-list` ;)



**ПОРАДИ**

* в залежності що ти вибереш – `nth-child` чи `nth-of-type` – селектор може стати більш крихким
* загугли щодо різниці і завжди обирай менш крихкий спосіб у твоєму контексті
  * [гугл](https://www.google.com/search?q=nth-child+vs+nth-of-type&oq=nth-child+vs+nth-of-type&aqs=chrome..69i57j0l2j69i60.10456j0j1&sourceid=chrome&ie=UTF-8) видасть тобі щось [таке](https://css-tricks.com/the-difference-between-nth-child-and-nth-of-type/) чи [таке](https://bitsofco.de/nth-child-vs-nth-of-type/)



,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ'ЯЗОК⇩**

=============



```python
browser.element('#todo-list>li:nth-of-type(2)...').click()
```

… не залежить від іншого типу елементів що можуть з’явитись поміж елементів `li` на тому самому рівні вкладеності, а тому є менш крихким і більш стабільним.





============================================================

#### Пошук по класу проти пошуку по CSS-класу{#by-class-vs-by-css-class}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/HU4DFBaJcYI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Будь-що з

```css
[class="foo foobar bar"]
```

```css
[class^=foo]
```

```css
[class$=bar]
```

```css
[class*=foobar]
```

… може зламатись якщо розробники додадуть ще одне слово (обрамлене пробілами) у значення атрибуту `class`, враховуючи що це слово:

* може вміщувати вже наявне інше слово в значенні
* може бути додане до початку значення чи в його кінець

І вони (розробники) ТОЧНО це зроблять. Тому що ці слова є так званими CSS-класами (на відміну від «класів» що є атрибутом з повним значенням з усіма такими «словами-CSS-класами»), які природно додаються до значення атрибуту `class` впродовж «життєвого циклу елемента» коли розробники, щоб додати елементу нової функції – «офіційно» записують його в ряди нової чи вже наявної групи елементів, чи то пак «класу елементів».



**ПОРАДИ**

* будуй селектор прив’язуючись до входження в атрибут `class` – точного слова, тобто так званого  СSS-класу



,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ'ЯЗОК⇩**

=============



```css
[class~='bar']
```

```css
[class~='foo']
```

```css
[class~='foobar']
```

```css
[class~='foo'][class~='bar']
```

чи стисліше і краще, бо є загальноприйнятим і всім відомим у світі фронтенду скороченням:

```css
.bar
```

```css
.foo
```

```css
.foobar
```

```css
.foo.bar
```





=================

### Перевірки {#assertions}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/ttgcHURYRgc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Перевірки прийнято ще називати «асертами» (assertions) в програмуванні.



#### Пропущений виклик методу `should`{#missed-should-method-call}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/i6pdFa6YFQc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

```python
browser.element('........')
```

```python
browser.all('............')
```

… не виконують ніякого пошуку елементів і відповідно перевірки їх існування. Такі виклики просто створюють об’єкти що представляють «локацію» відповідних елементів. Їх ще можна назвати «шукачами елементів», які запускають актуальний пошук тільки в момент певної дії як то `.click()` чи певної перевірки як то `.should(have.text('foo'))`.



,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ'ЯЗОК⇩**

=============



```python
browser.element('........').should(have.exact_text('...'))
```

```python
browser.all('............').should(have.exact_texts('...', '...'))
```



=====================================================================

#### Перевірка одного елементу замість всього списку {#asserting-one-element-insted-of-the-whole-list}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/5mlZmd3Yb-0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

```python
browser.element('.................').should(have.exact_text('...'))
```

або як у версії з уроку «Selene в дії»:

```python
browser.all('#todo-list>li').element_by(have.css_class('completed')\
    .should(have.exact_text('b'))
```

… пропустять баги коли після виконаної дії на елементі списку – побічним ефекторм будуть «клони» створенні елемента



**ПОРАДИ**

* за можливості, перевіряй весь список знайдений через `browser.all()`



,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ'ЯЗОК⇩**

=============



```python
browser.all('.....................').should(have.exact_texts('...'))
```

або як у версії з уроку «Selene в дії»:

```python
browser.all('#todo-list>li').filtered_by(have.css_class('completed')\
    .should(have.exact_texts('b'))
```



======================

### Феншуй Коду {#code-feng-shui}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/PSpzBIiVtDE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Code is like your house. Keeping it nice, clean and organized will help you to live in comfort and not being lost in the chaos;)

**ЗАГАЛЬНІ ПОРАДИ**

* вивчи і слідуй [PEP 8 -- Style Guide for Python Code](https://www.python.org/dev/peps/pep-0008/)
* звертай увагу на підказки в своєму редакторі коду (IDE), який зазвичай буде підсвічувати код, що порушує загальноприйняті домовленості, а після наведення мишки ще й покаже більш детальний опис



========================

#### Зайві пусті рядки{#extra-empty-lines}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/fJuEmDu11WA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

```python
from selene import have
from selene.support.shared import browser



def test_completes_todo():


        browser.open('http://todomvc.com/examples/emberjs')


        # ...code

        # ...code

```

… порушують правила з  [PEP 8: Blank Lines](https://www.python.org/dev/peps/pep-0008/#blank-lines)



**ПОРАДИ**

* звертай увагу на підказки в своєму редакторі коду (IDE), який зазвичай буде підсвічувати код, що порушує загальноприйняті домовленості, а після наведення мишки ще й покаже більш детальний опис
  ![image-20200423135042861](../resources/00-03-02-M-selene-and-css.assets/image-20200423135042861.png)
* often there will be a menu item to reformat your code correspondingly
  ![image-20200423135157569](../resources/00-03-02-M-selene-and-css.assets/image-20200423135157569.png)
  ![image-20200423135248600](../resources/00-03-02-M-selene-and-css.assets/image-20200423135248600.png)



,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ'ЯЗОК⇩**

=============



```python
from selene import have
from selene.support.shared import browser


def test_completes_todo():
        browser.open('http://todomvc.com/examples/emberjs')

        # ...code

        # ...code

```



============================

#### Занадто довгі рядки {#too-long-lines}

<iframe width="760" height="427.5" src="https://www.youtube.com/embed/tw9FL4EZayc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

```python
    browser.all('#todo-list>li').filtered_by(have.css_class('completed').should(have.exact_texts('b'))
```

… порушує «правило максимальної довжини рядків в 79 символів» з [PEP8: Maximum Line Length](https://www.python.org/dev/peps/pep-0008/#maximum-line-length)



**ПОРАДИ**

* це правило може бути не релевантним у сучасному світі «великих дисплеїв» :)
  * тому можеш встановити свою оптимальну границю довжини рядків, попередньо узгодивши її з командою
  * але врахуй що слідування такому класичному максимуму всього лиш в 79 символів може натренувати твої навички в написанні читабельного коду, навчитись «розбивати складне на простіші компоненти» (переносячи довгий код на наступні рядки)



,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

**⇩РОЗВ'ЯЗОК⇩**

=============



```python
    browser.all('#todo-list>li').filtered_by(have.css_class('completed')\
        .should(have.exact_texts('b'))
```



</uk>

<en>

**<p {{RED}}>Waiting for mistakes to be documented...</p>**

</en>

</py>